---
title: "Module 3 : JAX-RS avanc√©"
description: "JAX-RS avanc√©"
---

# Module 3 : JAX-RS avanc√©
Ce module vous offre le refactor d'une application JAX-RS pour appliquer les bonnes pratiques 
du monde Java et approfondir certains concepts associ√©s √† la gestion des exceptions 
et √† la s√©rialisation au sein du framework. 

Voici les sujets trait√©s :
- a) [Bonnes pratiques Java : "Factory" et injection de d√©pendances](/modules/3#sectionA)
- b) [Mapping d'exceptions √† des r√©ponses](/modules/3#sectionB)
- c) [S√©rialisation de POJOs et filtrage d'attributs](/modules/3#sectionC)
- d) [Exercice 3.1](/modules/3#sectionD)
- e) [üç¨ Exercice 3.2 optionnel](/modules/3#sectionE)

<br/>

# <a id="sectionA"></a>a) Bonnes pratiques Java : "Factory" et injection de d√©pendances
## a.1) Introduction
Dans les modules 1 & 2, nous avons d√©velopp√© ensemble une RESTful API permettant de g√©rer des films.

Nous allons maintenant faire un refactor de cette application afin de mieux architecturer le code.
Voici les motivations pour r√©architecturer l'API :
- abstraction de l'impl√©mentation de classes par l'utilisation d'interfaces ; 
ainsi, lors d'interactions entre des objets de diff√©rents types, on ne doit pas se soucier 
de l'impl√©mentation des classes ; l'auteur d'une classe peut mettre √† jour son impl√©mentation 
sans casser les interactions avec celle-ci ; 
cela participe √† la mise en place d'un couplage faible entre objets ;
- √©viter le couplage fort entre objets, notamment en injectant les objets de service 
(n'ayant pas d'√©tats) et en utilisant des ¬´ Factory ¬ª pour cr√©er des objets 
du domaine (ayant un √©tat).

<br/>

## a.2) Les ¬´ Factory ¬ª
Une ¬´ Factory ¬ª permet de cr√©er des objets sans exposer leur logique de cr√©ation 
(au programme client appelant ces objets).
<br/>

On cr√©era donc des objets du domaine, des objets ayant un √©tat, via une ¬´ Factory ¬ª sp√©cifique.
<br/>

De plus, pour ne pas d√©pendre d'une ¬´ Factory ¬ª sp√©cifique, on pourra cr√©er une interface 
pour chaque impl√©mentation d'une ¬´ Factory ¬ª.
<br/>

Nous allons donc mettre √† jour notre API de gestion de films pour utiliser une factory :
-	Extraire l'interface de **Film**. Via IntelliJ :
    - Clic droit sur **Film**, **Refactor**, **Extract Interface...**
    - S√©lection de **Rename original class and use interface where possible**
    - Pour **Rename implementation class to**, √©crivez : **FilmImpl**
    - Pour **Members To Form Interface**, s√©lectionnez (quasi) tout ; il n'est pas utile de 
    s√©lectionner les m√©thodes qui red√©finissent la classe **Object** (**toString**, **equals**, 
    **hashCode**...)
-	L'interface **Film** est maintenant impl√©ment√©e par **FilmImpl**
-	De la m√™me fa√ßon, veuillez extraire l'interface de **User** et renommer la classe 
**User** en **UserImpl**.
- Attention, les classes impl√©mentant vos interfaces ne doivent pas √™tre **public**.
Supprimez **public** pour rendre vos classes "package friendly". Ainsi, seulement la factory 
aura la possibilit√© de cr√©er des objets du domaine.
- Cr√©er la classe **DomainFactory** au sein du package **domain**. Voici le code :
```java
package be.vinci.domain;

public class DomainFactory{
    @Override
    public Film getFilm() {
        return new FilmImpl();
    }

    @Override
    public User getUser() {
        return new UserImpl();
    }
}
```
- Extraire l'interface de **DomainFactory** et renommer cette classe en **DomainFactoryImpl** : 
le contrat (ou l'interface) **DomainFactory** est maintenant impl√©ment√©e par le service **DomainFactoryImpl** qui permet la cr√©ation d'instance de **FilmImpl** ou de **UserImpl**.
- Mettez √† jour le code de votre API partout o√π des objets du domaine sont cr√©√©s en utilisant 
la factory. Dans un premier temps, nous allons cr√©er une instance de la factory l√† o√π 
elle doit √™tre utilis√©e. Par la suite, nous verrons comment injecter une d√©pendance et devenir
ind√©pendant de l'impl√©mentation de la factory l√† o√π elle est utilis√©e.
Le seul endroit o√π l'on cr√©e un objet du domaine directement, c'est dans **UserDataService**. 
Modifiez cette classe :
```java {3,9}
public class UserDataService {
    //...
    private static DomainFactory myDomainFactory = new DomainFactoryImpl();
    //...
    public ObjectNode register(String login, String password) {
        User tempUser = getOne(login);
        if (tempUser != null) // the user already exists !
            return null;
        tempUser = myDomainFactory.getUser();
    //...
```
- V√©rifiez dans **FilmDataService** et **UserDataService** que **jsonDB** est cr√©√© en passant 
l'interface (et non l'impl√©mentation), par exemple pour **UserDataService** :
```java
private static Json<User> jsonDB = new Json<>(User.class);
```

<br/>

A ce stade-ci, la librairie **Jackson** qui s'occupe de la d√©s√©rialisation ne connait pas 
l'impl√©mentation √† utiliser pour les POJOs. 
<br/>

Si vous ex√©cutez l'application, elle lancera des exceptions lorsque vous appellerez certaines 
op√©rations.

<br/>

## a.3) D√©s√©rialisation vers des POJOs cach√©s par une interface
Afin de diminuer le couplage des objets, les objets du domaine sont cach√©s 
derri√®re des interfaces.
<br/>

Afin que **Jackson** sache quelle impl√©mentation est √† utiliser pour la d√©s√©rialisation 
de JSON vers des POJOs associ√©s √† une interface, il faut l'indiquer via l'annotation
**@JsonDeserialize**.
<br/>

Veuillez mettre √† jour le code de **Film** :
```java {3}
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;

@JsonDeserialize(as = FilmImpl.class)
public interface Film {

```

<br/>


Veuillez mettre √† jour le code de **User** : 
```java {3}
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;

@JsonDeserialize(as = UserImpl.class)
public interface User {
```

<br/>

Veuillez ex√©cuter l'application et vous assurer que tout est en ordre.
<br/>

## a.4) L'injection de d√©pendances
Afin d'injecter des d√©pendances au sein d'une application impl√©mentant Jakarta EE, 
¬´ Jakarta Dependency Injection ¬ª (ou Jakarta DI) permet d'obtenir des objets tout 
en maximisant la r√©utilisation, la testabilit√© et la maintenabilit√© en comparaison 
avec des approches plus traditionnelles (utilisation de constructeurs‚Ä¶).

Pour pouvoir utiliser les API d'injection de d√©pendances au sein de Jersey, 
voici la librairie qui est contenue dans l'achetype Maven utilis√© (voir fichier **pom.xml**) :
```xml
<dependency>
        <groupId>org.glassfish.jersey.inject</groupId>
        <artifactId>jersey-hk2</artifactId>
</dependency>
```

<br/>

Les services principaux de CDI (Contexts & Dependency Injection) sont :
- Mise √† disposition de contextes afin de lier le cycle de vie et les interactions de composants 
ayant un √©tat avec des contextes bien d√©finis ;
- L'injection de d√©pendance afin d'injecter des composants dans un application et choisir √† 
l'ex√©cution l'impl√©mentation particuli√®re d'une interface (= le service) √† injecter.

<br/>

Pour injecter un objet au sein d'une classe, il faut :
- Configurer votre application JAX-RS pour indiquer comment l'injection de d√©pendance doit cr√©er vos instances ; on peut le faire via **bind(service).to(contrat)** et le cha√Æner avec **.in( scope)**. Les scopes disponibles sont :
    - **PerLookup** : pour chaque appel du service une instance du contrat est cr√©√©e.
    - **RequestScoped** : une instance cr√©√© pour chaque requ√™te.
    - **Singleton** : une seule instance du contrat cr√©√© par service.
- Faire le binding via la red√©finition d'un **AbstractBinder**. Nous allons lier le contrat de 
**DomainFactory** au service **DomainFactoryImpl** pour que une et une seul instance soit cr√©√©e 
et puisse √™tre inject√©e dans l'application l√† o√π n√©cessaire.
Pour ce faire, veuillez cr√©er la classe **ApplicationBinder** au sein du package **utils** :
```java
package be.vinci.utils;

import be.vinci.domain.DomainFactory;
import be.vinci.domain.DomainFactoryImpl;
import org.glassfish.hk2.utilities.binding.AbstractBinder;


import jakarta.inject.Singleton;
import jakarta.ws.rs.ext.Provider;

@Provider
public class ApplicationBinder extends AbstractBinder {

    @Override
    protected void configure() {
        bind(DomainFactoryImpl.class).to(DomainFactory.class).in(Singleton.class);
    }
}
```
- Dans **Main**, il faut configurer l'application pour qu'elle utilise le nouveau Provider (**ApplicationBinder**).
Veuillez mettre √† jour **ResourceConfig** :
```java {2}
final ResourceConfig rc = new ResourceConfig().packages("be.vinci.api")
        .register(ApplicationBinder.class);
```
- Pour rappel, l'annotation **@Provider** ci-dessus permet de fournir notre propre impl√©mentation 
d'un provider, de la rendre disponible √† l'ex√©cution, √† notre application JAX-RS.
- Nous allons maitenant injecter la factory via l'annotation **@Inject**, qui sera inject√©e 
sous forme de **Singleton** (une et une seule instance) conform√©ment √† sa configuration 
au sein de l'**AbstractBinder**. Veuillez mettre √† jour le code de **UserDataService** :
```java {3,9}
public class UserDataService {
    //...
    @Inject
    private DomainFactory myDomainFactory;
    //...    
```

<br/>

Veuillez ex√©cuter l'application et vous assurer que tout est en ordre.

<br/>

Pour l'injection de d√©pendance au sein de Jakarta, une bonne documentation n'est pas √©vidente 
√† trouver. Les notions donn√©es ci-dessus devraient √™tre suffisantes pour avancer. 
<br/>

Les services de donn√©es sont aussi des d√©pendances qui peuvent √™tre utilis√©es √† diff√©rents 
endroit dans votre code. Nous allons donc utiliser le framework afin d'injecter ces d√©pendances.
<br/>

Dans un premier temps, veuillez extraire l'interface de **FilmDataService** comme expliqu√© 
pr√©c√©demment et renommer la classe en **FilmDataServiceImpl**.

Veuillez aussi extraire l'interface de **UserDataService** et renommer la classe 
en **UserDataServiceImpl**.

Veuillez mettre √† jour **ApplicationBinder** afin d'indiquer les impl√©mentations √† utiliser ainsi 
que le scope des instances :
```java {7-8}
@Provider
public class ApplicationBinder extends AbstractBinder {

    @Override
    protected void configure() {
        bind(DomainFactoryImpl.class).to(DomainFactory.class).in(Singleton.class);
        bind(FilmDataServiceImpl.class).to(FilmDataService.class).in(Singleton.class);
        bind(UserDataServiceImpl.class).to(UserDataService.class).in(Singleton.class);
    }
}
```
<br/>

Il reste maintenant √† injecter les instances de nos services de donn√©es l√† o√π n√©cessaire, au 
sein de nos Root Resources et de nos filtres (package **api**).

Modifiez **FilmResource** :
```java {4-5}
@Singleton
@Path("films")
public class FilmResource {
    @Inject
    private FilmDataService myFilmDataService;
```
<br/>

Modifiez **AuthsResource** :
```java {4-5}
@Singleton
@Path("/auths")
public class AuthsResource {
    @Inject
    private UserDataService myUserDataService;
```
<br/>

Modifiez **AuthorizationRequestFilter** :
```java {7-8}
@Singleton
@Provider
@Authorize
public class AuthorizationRequestFilter implements ContainerRequestFilter {
    private final Algorithm jwtAlgorithm = Algorithm.HMAC256(Config.getProperty("JWTSecret"));
    private final JWTVerifier jwtVerifier = JWT.require(this.jwtAlgorithm).withIssuer("auth0").build();
    @Inject
    private UserDataService myUserDataService ;
```
<br/>

Voila, le refactoring du code est termin√©. 

Veuillez ex√©cuter l'application et vous assurer que tout est en ordre.
<br/>

Voici quelques r√©f√©rences si vous souhaitiez approfondir le sujet de CDI :
- Basique Injection de d√©pendances via Jersey's HK2 : https://riptutorial.com/jersey/example/23632/basic-dependency-injection-using-jersey-s-hk2 
- L'API pour l'injection de d√©pendance de Jakarta fournit quelques infos int√©ressantes : https://jakarta.ee/specifications/cdi/3.0/apidocs/
- La sp√©cification pour l'injection de d√©pendance : https://jakarta.ee/specifications/cdi/3.0/jakarta-cdi-spec-3.0.html

<br/>

# <a id="sectionB"></a>b) Mapping d'exceptions √† des r√©ponses
## b.1) Introduction
Dans le module 1 nous avons vu comment renvoyer des codes et des messages d'erreur 
√† l'aide de **WebApplicationException**.
<br/>

Il est possible aussi, au sein d'une application JAX-RS, de mapper directement 
une Java Exception √† une r√©ponse http d'erreur.

Ceci est d√©crit dans le manuel utilisateur de Jersey : https://eclipse-ee4j.github.io/jersey.github.io/documentation/latest3x/representations.html#d0e6279

En r√©sum√©, il suffit :
-	soit de d√©finir une exception sp√©cifique qui √©tend **WebApplicationException** ; 
-	soit d'utiliser un provider personnalis√© pour mapper une exception √† une r√©ponse ;
dans ce cas, le provider doit impl√©menter l'interface **`ExceptionMapper<E extends Throwable>`**. 

<br/>

## b.2) Exceptions h√©ritant de WebApplicationException
Il est possible de cr√©er ses propres classes d'exceptions o√π l'exception prend directement 
en charge une r√©ponse HTTP d'erreur au client.

Dans le package **api.filters**, veuillez cr√©er la classe **TokenDecodingException** :
```java
package be.vinci.api.filters;

import jakarta.ws.rs.WebApplicationException;
import jakarta.ws.rs.core.Response;

public class TokenDecodingException extends WebApplicationException {
    public TokenDecodingException() {
        super(Response.status(Response.Status.UNAUTHORIZED)
                .build());
    }

    public TokenDecodingException(String message) {
        super(Response.status(Response.Status.UNAUTHORIZED)
                .entity(message)
                .type("text/plain")
                .build());
    }

    public TokenDecodingException(Throwable cause) {
        super(Response.status(Response.Status.UNAUTHORIZED)
                .entity(cause.getMessage())
                .type("text/plain")
                .build());
    }
}
```

<br/>

Au sein de **AuthorizationRequestFilter**, modifiez le code pour appeler 
la nouvelle exception :
```java {12}
@Override
public void filter(ContainerRequestContext requestContext) throws IOException {
    String token = requestContext.getHeaderString("Authorization");
    if (token == null) {
        requestContext.abortWith(Response.status(Response.Status.UNAUTHORIZED)
                .entity("A token is needed to access this resource").build());
    } else {
        DecodedJWT decodedToken = null;
        try {
            decodedToken = this.jwtVerifier.verify(token);
        } catch (Exception e) {
            throw new TokenDecodingException(e);
        }
```

<br/>

Ajoutez une nouvelle requ√™te permettant de tester cette nouvelle exception au sein de 
**films.http** :
```http-request {4}
### Test the TokenDecoding Exception
POST {{baseUrl}}/films
Content-Type: application/json
Authorization: {{jamesToken}}modifiedtoken

{
  "title": "Venom: Let There Be Carnage",
  "duration": 9,
  "budget": 110,
  "link": "https://en.wikipedia.org/wiki/Venom:_Let_There_Be_Carnage"
}
```

<br/>

## b.3) Mapping d'exceptions √† des r√©ponses
Le r√¥le des Root Resources est notamment de pr√©parer des r√©ponses aux clients. Il est donc OK 
de lancer des **WebApplicationException** √† ce niveau l√†.
<br/>

Pour les exceptions lanc√©es dans d'autres parties du code, comme par exemple dans 
les services de donn√©es,  il est int√©ressant que les exceptions qui am√®nent √† une 
r√©ponse au client soient trait√©es de mani√®re centralis√©e plut√¥t que de g√©rer des 
**try** / **catch** un peu partout.
<br/>

On peut aussi souhaiter centraliser certains traitement pour toutes les exceptions lanc√©es,
y-compris les **WebApplicationException** lanc√©es dans les Root Resources.

La centralisation de ces traitements d'exception peut se faire au sein d'un **ExceptionMapper**.
C'est un lieu id√©al pour traiter de tous les codes et messages d'erreur √† envoyer aux client,
pour cr√©er des logs...
<br/>

Nous allons cr√©er une **ExceptionMapper** nomm√© **WebExceptionMapper** dans le package **utils** 
qui doit attraper toutes les exceptions, afficher la stack trace, puis envoyer une r√©ponse 
au client. Si de l'exception est de type **WebApplicationException**, on souhaite envoyer une r√©ponse contenant le **status** 
et **message** de celle-ci. Sinon on renvoie le code d'erreur **INTERNAL_SERVER_ERROR** et 
le message associ√© √† l'exception  :
```java
package be.vinci.utils;

import jakarta.ws.rs.WebApplicationException;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.ext.ExceptionMapper;
import jakarta.ws.rs.ext.Provider;

@Provider
public class WebExceptionMapper implements ExceptionMapper<Throwable> {
    @Override
    public Response toResponse(Throwable exception) {
        exception.printStackTrace();
        if (exception instanceof WebApplicationException)
            return ((WebApplicationException) exception).getResponse(); // the response is already prepared
        return  Response.status( Response.Status.INTERNAL_SERVER_ERROR)
                .entity(exception.getMessage())
                .build();
    }
}
```

<br/>

Dans **Main**, il faut configurer l'application pour qu'elle utilise le nouveau Provider (**WebExceptionMapper**).
Veuillez mettre √† jour **ResourceConfig** :
```java {3}
final ResourceConfig rc = new ResourceConfig().packages("be.vinci.api")
        .register(ApplicationBinder.class)
        .register(WebExceptionMapper.class);
```

<br/>

Il y a un probl√®me au niveau de Jersey. Si l'exception de type **WebApplicationException** 
contient une r√©ponse, les ExceptionMappers ne seront pas appel√©s : https://stackoverflow.com/questions/46339265/how-to-catch-webapplicationexception-with-jax-rs

D√®s lors, nous devons mettre √† jour le code des **WebApplicationException** lanc√©es afin de faire appel 
au constructeur prenant le code d'erreur en 1er param√®tre, puis le message d'erreur en deuxi√®me 
param√®tre. Mettez √† jour le code des classes **AuthsResource**, **FilmResource** et **TokenDecodingException**.

Voici un exemple de mise √† jour pour **AuthsResource** :
```java numbered {14,21,33,41}
@Singleton
@Path("/auths")
public class AuthsResource {
    @Inject
    private UserDataService myUserDataService;

    @POST
    @Path("login")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public ObjectNode login(JsonNode json) {
        // Get and check credentials
        if (!json.hasNonNull("login") || !json.hasNonNull("password")) {
            throw new WebApplicationException("login or password required", Response.Status.BAD_REQUEST);
        }
        String login = json.get("login").asText();
        String password = json.get("password").asText();
        // Try to login
        ObjectNode publicUser = myUserDataService.login(login, password);
        if (publicUser == null) {
            throw new WebApplicationException("Login or password incorrect", Response.Status.UNAUTHORIZED);
        }
        return publicUser;
    }

    @POST
    @Path("register")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public ObjectNode register(JsonNode json) {
        // Get and check credentials
        if (!json.hasNonNull("login") || !json.hasNonNull("password")) {
            throw new WebApplicationException("login or password required", Response.Status.BAD_REQUEST);
        }
        String login = json.get("login").asText();
        String password = json.get("password").asText();

        // Try to login
        ObjectNode publicUser = myUserDataService.register(login, password);
        if (publicUser == null) {
            throw new WebApplicationException("this resource already exists", Response.Status.CONFLICT);
        }
        return publicUser;

    }

}
```

<br/>

Veuillez ex√©cuter l'application et vous assurer que tout est en ordre.
<br/>

# <a id="sectionC"></a>c) S√©rialisation de POJOs et filtrage d'attributs
## c.1) Introduction
Il existe pas mal de situation o√π l'on souhaiterait renvoyer qu'un subset des attributs 
d'un POJO (ou d'une liste de POJOs). 

Imaginez par exemple que l'on souhaite lire la liste de tous les utilisateurs.
<br/>

Veuillez ajouter la classe **UserResource** au sein du package **api** :
```java
package be.vinci.api;

import be.vinci.api.filters.Authorize;
import be.vinci.domain.User;
import be.vinci.services.UserDataService;
import jakarta.inject.Inject;
import jakarta.inject.Singleton;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

import java.util.List;

@Singleton
@Path("/users")
public class UserResource {

    @Inject
    private UserDataService myUserDataService;

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Authorize
    public List<User> getAll() {
        return myUserDataService.getAll();
    }

}
```

<br/>

Nous allons tester l'op√©ration de lecture des utilisateurs qui est prot√©g√©e par un token.

Ajoutez le script **user.http** √† votre projet ou module IntelliJ :
```http-requests
### Login the default user
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
"login":"james",
"password":"password"
}

> {%
client.global.set("jamesToken", response.body.token);
%}

### Read All users
GET {{baseUrl}}/users
Authorization: {{jamesToken}}
```

<br/>

Si vous utilisez VS Code, convertissez ce script en cr√©ant une request variable pour r√©cup√©rer 
le token.

<br/>

Veuillez ex√©cutez l'API de gestion de films et lancer les requ√™tes du script **user.http**.

On remarque que toutes les informations des utilisateurs, y-compris le password, sont renvoy√©es 
au client. 
Dans ce cas-ci, il est important de filtrer l'attribut password de la repr√©sentation JSON qui sera 
renvoy√©e au client.
<br/>

Il existe plusieurs m√©canismes pour filtrer des attributs lors d'op√©rations de 
s√©rialisation vers du JSON ou de d√©s√©rialisation √† partir de JSON.
<br/>

## c.2) Filtrer des attributs de la repr√©sentation JSON d'un POJO : les vues JSON
Un des m√©canismes de filtrage d'attributs qui a √©t√© s√©lectionn√© pour ce cours est la 
cr√©ation de vues JSON au sein d'un POJO.
<br/>

Ce m√©canisme est r√©ellement utile dans les cas o√π l'on doit filtrer diff√©remment les attributs 
d'un m√™me POJO en fonction de l'op√©ration de s√©rialisation.

Par exemple, si vous devez s√©rialiser des donn√©es lors d'une r√©ponse √† un client, vous 
ne souhaitez pas s√©rialiser le **password** d'un **User**.
Par contre, lorsque vous s√©rialiser des donn√©es au sein d'un fichier JSON, pour enregistrer 
les donn√©es d'un nouvel **User**, l√† vous souhaitez s√©rialiser le **password**.
<br/>

Pour ce faire, nous allons cr√©er deux vues JSON que nous pourrons associer au POJO **User** impl√©ment√© 
par **UserImpl** : 
- une vue publique qui contient tous les attributs qui peuvent √™tre lus par les clients de 
l'API (l'id et le login dans le cadre d'un **User**) ;
- une vue interne qui contient tous les attributs qui peuvent √™tre √©crits par l'API suite 
aux op√©rations de cr√©ation et de mise √† jour d'une ressource 
(l'id, le login et le password dans le cadre d'un **User**).

<br/>

Veuillez cr√©er le package **view** et y ajouter la class **Views** : 
```java
package be.vinci.views;

public class Views {
    public static class Public {
    }

    public static class Internal extends Public {
    }

}
```

<br/>

Cette classe **Views** va nous permettre d'annoter des vues JSON gr√¢ce aux deux classes 
imbriqu√©es vides.
<br/>

Attention √† ce que la vue qui doit reprendre tous les attributs √©tende la vue plus restreinte.
<br/>

Ensuite, nous pouvons annotez nos vues JSON au sein du POJO **UserImpl** 
via l'annotation **@JsonView** :
```java {1,3,5,7}
@JsonInclude(JsonInclude.Include.NON_NULL) // ignore all null fields in order to avoid sending props not linked to a JSON view
class UserImpl implements User {
    @JsonView(Views.Public.class)
    private int id;
    @JsonView(Views.Public.class)
    private String login;
    @JsonView(Views.Internal.class)
    private String password;

    @Override
    public String getLogin() {
        return login;
    }
    //.....
```

<br/>

L'annotation **@JsonInclude(JsonInclude.Include.NON_NULL)** est tr√®s importante : 
elle indique que seulement les attributs non nuls seront inclus dans la s√©rialisation.
<br/>

Pour filtrer seulement la vue publique d'une POJO lors de la s√©rialisation, 
voici ce qui doit encore √™tre fait. 
On va renvoyer un POJO, ou une liste de POJOs dont tous les champs qui ne font pas partie 
de la vue publique sont initialis√©s √† la valeur par d√©faut (**null** pour les objets). 
<br/>

Puis, au sein d'une Root Resource (**UserResource**) on renverra ce POJO, ou liste de POJOs, 
et la s√©rialisation sera fait automatiquement 
vers du JSON, en ignorant les champs nuls (car, pour rappel, nous avons indiqu√© 
**@JsonInclude(JsonInclude.Include.NON_NULL)** au sein de **UserImpl**).
<br/>

Veuillez ajouter deux m√©thodes au sein de la classe **Json** permettant de filtrer 
une vue publique :
```java
public <T> List<T> filterPublicJsonViewAsList(List<T> list) {
    try {
        JavaType type = jsonMapper.getTypeFactory().constructCollectionType(List.class, this.type);
        // serialize using JSON Views : public view (all fields not required in the
        // views are not serialized)
        String publicItemListAsString = jsonMapper.writerWithView(Views.Public.class).writeValueAsString(list);
        // deserialize using JSON Views : Public View (all fields that are not serialized
        // are set to their default values in the POJOs)
        return jsonMapper.readerWithView(Views.Public.class).forType(type).readValue(publicItemListAsString);
    } catch (JsonProcessingException e) {
        e.printStackTrace();
        return null;
    }

}

public <T> T filterPublicJsonView(T item) {
    try {
        // serialize using JSON Views : public view (all fields not required in the
        // views are not serialized)
        String publicItemAsString = jsonMapper.writerWithView(Views.Public.class).writeValueAsString(item);
        // deserialize using JSON Views : Public View (all fields that are not serialized
        // are set to their default values in the POJO)
        return jsonMapper.readerWithView(Views.Public.class).forType(type).readValue(publicItemAsString);
    } catch (JsonProcessingException e) {
        e.printStackTrace();
        return null;
    }

}
```

<br/>

Il nous reste √† filtrer la liste de POJOs renvoy√©e par la m√©thode **getAll** de **UserDataServiceImpl**.
Veuillez mettre √† jour la m√©thode **getAll** :
```java {4}
@Override
public List<User> getAll() {
    var items = jsonDB.parse(COLLECTION_NAME);
    return jsonDB.filterPublicJsonViewAsList(items);
}
```

<br/>

La m√©thode **filterPublicJsonViewAsList** va mettre les valeurs par d√©faut 
pour tous les champs non publics (ici juste le password) d'un **User** et 
renvoyer une liste de **User**.

Ensuite, la m√©thode **getAll** de **UserResource** va renvoyer cette liste de **User** : 
```java {4}
@GET
@Produces(MediaType.APPLICATION_JSON)
@Authorize
public List<User> getAll() {
    System.out.println("getAll");
    return myUserDataService.getAll();
}
```

<br/>

Le framework, via Jackson, va automatiquement convertir cette liste de **User** dont le password 
est √† null (valeur par d√©faut d'une **String**) en JSON, sans s√©rialiser le champs **password** 
car nous avons annot√© (**@JsonInclude(JsonInclude.Include.NON_NULL)**) **UserImpl** 
pour sp√©cifier que seulement les attributs non nuls seront inclus dans la s√©rialisation.

<br/>

Veuillez ex√©cutez l'API de gestion de films et lancer les requ√™tes du script **user.http**.

Vous remarquerez que le champs **password** a bien √©t√© filtr√© !
<br/>

**Attention** : cette m√©thode de filtrage peut causer des soucis si vous devez filtrer 
des attributs de type primitif : **int**, **double**, **boolean**... 
La valeur par d√©faut de ces attributs, n'est pas **null**. D√®s lors, ces attributs 
ne pourront pas √™tre filtr√©s et seront s√©rialis√©s m√™me si vous les annoter de 
**@JsonView(Views.Internal.class)**.

<br/>

Pour visualiser cela, nous allons tester l'ajout d'un **User** avec deux nouvelles propri√©t√©s.
Veuillez mettre √† jour **UserImpl**:
 ```java {1,9-12}
@JsonInclude(JsonInclude.Include.NON_NULL) // ignore all null fields in order to avoid sending props not linked to a JSON view
class UserImpl implements User {class UserImpl implements User {
    @JsonView(Views.Public.class)
    private int id;
    @JsonView(Views.Public.class)
    private String login;
    @JsonView(Views.Internal.class)
    private String password;
    @JsonView(Views.Internal.class)
    private int age;
    @JsonView(Views.Internal.class)
    private boolean married ;    

    @Override
    public int getAge() {
        return age;
    }

    @Override
    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public boolean isMarried() {
        return married;
    }

    @Override
    public void setMarried(boolean married) {
        this.married = married;
    }
    //.....
```

<br/>

Veuillez aussi mettre √† jour **User** en ajoutant ce code :
```java {3-9}
@JsonDeserialize(as = UserImpl.class)
public interface User {
    int getAge();

    void setAge(int age);

    boolean isMarried();

    void setMarried(boolean married);
```

<br/>

Veuillez mettre √† jour la m√©thode **register** de **AuthsResource** (on va r√©cup√©rer un **User** plut√¥t qu'un **JsonNode**):
```java {5,7-8,12}
@POST
@Path("register")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public ObjectNode register(User user) {
    // Get and check credentials
    if (user == null || user.getPassword() == null || user.getPassword().isBlank()
    || user.getLogin() == null || user.getLogin().isBlank()) {
        throw new WebApplicationException("login or password required", Response.Status.BAD_REQUEST);
    }
    // Try to login
    ObjectNode publicUser = myUserDataService.register(user);
    if (publicUser == null) {
        throw new WebApplicationException("this resource already exists", Response.Status.CONFLICT);
    }
    return publicUser;

}
```

<br/>

Veuillez mettre √† jour la m√©thode **register** de **UserDataServiceImpl** (r√©ception d'un **User** plut√¥t que d'un **login** et d'un **password**.) :
```java {1-2}
 @Override
public ObjectNode register(User user) {        
    if (getOne(user.getLogin()) != null) // the user already exists !
        return null;        
    
    user.setPassword(user.hashPassword(user.getPassword()));

    user = createOne(user); // add an id to the user and serialize it in db.json
```

<br/>

Veuillez aussi mettre √† jour l'interface **UserDataService** (param√®tre de type **User** plut√¥t que un **login** et un **password** sous forme de **String**):
```java {1}
ObjectNode register(User user);
```

<br/>

Veuillez ajouter ces nouvelles requ√™tes HTTP dans votre fichier **users.http** :
```http-requests {1}
### Register twig
POST {{baseUrl}}/auths/register
Content-Type: application/json

{
  "login":"twig",
  "password":"twig",
  "age": 25,
  "married": true
}

### Login twig
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
  "login":"twig",
  "password":"twig"
}

> {%
client.global.set("twigToken", response.body.token);
%}

### Read All users
GET {{baseUrl}}/users
Authorization: {{twigToken}}
```

<br/>

Veuillez ex√©cuter ces 3 requ√™tes dans l'ordre.
On voit que la derni√®re requ√™te nous renvoie tant **age** que **married** alors qu'on souhaite 
les filtrer. De plus, les valeurs renvoy√©es sont les valeurs par d√©faut des attributs, m√™me si 
on avait initialis√©s ceux-ci.
<br/>

Pour r√©soudre cela, dans un premier temps, nous allons filtrer lors de la s√©rialisation 
tous les attributs qui ont une valeur par d√©faut.

Pour visualiser cela, veuillez mettre √† jour **UserImpl**:
 ```java {1}
@JsonInclude(JsonInclude.Include.NON_DEFAULT) // ignore all default fields in order to avoid sending props not linked to a JSON view
class UserImpl implements User {class UserImpl implements User {
    @JsonView(Views.Public.class)    
    //.....
```

<br/>

Veuillez ex√©cuter la derni√®re requ√™tes HTTP de votre fichier **users.http** :
```http-requests 
### Read All users
GET {{baseUrl}}/users
Authorization: {{twigToken}}
```

La limitation de cette solution, c'est que vous ne pouvez pas s√©rialiser les valeurs par d√©faut.

Cela peut √™tre acceptable si vous ne devez jamais s√©rialiser des **0** pour des nombres, 
par contre, √ßa ne l'est pas si vous devez s√©rialiser des **boolean** : si la valeur est 
**false** pour un attribut : il sera d'office filtr√© (valeur par d√©faut d'un boolean) 
m√™me si √ßa n'est pas ce que l'on veut. 
N'h√©sitez pas √† visualiser ce sc√©nario si cela vous int√©resse : il suffit d'appliquer la vue **Public** 
√† l'attribut **married** de **UserImpl** et de r√©ex√©cuter la derni√®re requ√™te HTTP 
de **users.http**.

<br/>

Pour r√©soudre cette derni√®re partie, nous pouvons utiliser les "**Wrappers**" 
des types primitifs : **Integer**, **Boolean**.
<br/>

Veuillez convertir **age** en **Integer** et **married** en **Boolean** au sein de **UserImpl**.
Pour ce faire via IntelliJ : clic droit sur le type d'un attribut, **Refactor**, 
**Type Migration...**, indiquez le nouveau type (**Integer** ou **Boolean**) puis clic sur 
**Refactor**
<br/>

Une fois cela r√©alis√©, ex√©cutez votre API.

Vous verrez que les attributs filtr√©s ne sont plus s√©rialis√©s lors de la r√©ponse faite 
aux requ√™tes clients. De plus, les attributs non 
initialis√©s (dont la valeur vaut "null") ne sont pas s√©rialis√©s au sein de **db.json**
(la m√©thode **valueToTree** dans **Json** ne cr√©e pas de propri√©t√© JSON pour les attributs 
qui sont "null").
<br/>

## c.3) Filtrer des attributs de la repr√©sentation JSON d'un POJO : sp√©cifier l'acc√®s √† une propri√©t√©
Un autre m√©canisme de filtrage d'attributs est la sp√©cification de comment les attributs peuvent 
√™tre acc√©d√©s pendant la s√©rialisation ("**read**" du point de vue la propri√©t√© du POJO) 
et la d√©s√©rialisation ("**write**"").

Il est plus simple √† mettre en place que le m√©canisme pr√©c√©dent.
<br/>

Ce m√©canisme est applicable que dans les cas o√π toutes les op√©rations de s√©rialisation d'un m√™me POJO doivent filtrer les m√™mes atttributs. Par exemple, si vous devez s√©rialiser des donn√©es que lors de l'envoi des donn√©es aux clients, et que vous souhaitez toujours filtrer les m√™mes donn√©es, alors ce m√©canisme vous est recommand√©.
<br/>

C'est √©ventuellement le cas lorsque l'on utilise une base de donn√©es pour faire persister les donn√©es.  
Comme on ne doit pas s√©rialiser les donn√©es pour les enregistrer dans un fichier JSON, on doit juste filtrer les donn√©es lorsqu'elles sont renvoy√©es au format JSON pour r√©pondre aux requ√™tes clientes.
<br/>

Voici au sein de **UserImpl** un exemple de comment filtrer l'attribut **password** 
pour toutes les op√©rations de s√©rialisation d'un **User** :
```java {1}
class UserImpl implements User {
    private int id;
    private String login;
    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
    private String password;
    private Integer age;
    private Boolean married ;  
    //.....
```

<br/>

Le simple ajout de l'annotation **@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)** permet 
de ne jamais s√©rialiser le **password**. Par contre, il sera possible de d√©s√©rialiser du JSON 
(contenant une propri√©t√© **password**) pour cr√©er un objet **User**.
<br/>

Les diff√©rentes sp√©cifications d'acc√®s aux propri√©t√©s lors de la s√©rialisation sont d√©finis ici :
https://www.javadoc.io/doc/com.fasterxml.jackson.core/jackson-annotations/latest/index.html

<br/>

**Code du tutoriel** : si vous souhaitez directement acc√©der au code de la fin du tutoriel de 
cr√©ation d'une API de gestion de films pour ce module 3 : 
https://github.com/e-vinci/baja-demos/tree/main/films-api

<br/>

# <a id="sectionD"></a>d) Excercice 3.1
Nous souhaitons continuer le d√©veloppement du Headless CMS d√©marr√© au module 2. 

Veuillez faire un refactoring du code de l'exercice 2.1 selon les concepts vus dans 
ce module 3 : abstraction de l'impl√©mentation de classes par l'utilisation d'interfaces, 
ajout de factory et injection de d√©pendances.
<br/>

Veuillez centraliser la gestion des exceptions au sein d'un **ExceptionMapper** pour notamment 
envoyer chaque message d'exception associ√© √† une requ√™te dans le corps de la r√©ponse.
<br/>
 
Veuillez relancer les tests des m√©thodes offertes par votre application JAX-RS √† l'aide d'un 
client l√©ger (HTTP client d'IntelliJ ou Rest Client de VS Code) pour vous assurer que votre 
refactoring est OK.
<br/>
<br/>

Est-ce que vous avez des blocs **try/catch** dans **PageResource** ?

Si oui, faites-en sorte de les supprimer, tout en continuant de renvoyer un message d'erreur 
au clients si n√©cessaire.
<br/>

Quelques tips :
- Continuez le projet d√©velopp√© dans le cadre de l'Exercice 2.1 du module 2. Il n'est pas n√©cessaire 
de cr√©er un nouveau projet.
- Reprenez **WebExceptionMapper**, vu dans le tutoriel de ce module 3, au sein de votre projet.

<br/>

# <a id="sectionE"></a>e) üç¨ Excercice 3.2 optionnel
Nous souhaitons continuer le d√©veloppement du Headless CMS d√©marr√© au module 2. 
Pour ce faire, nous allons cr√©er la RESTful API qui s'occupera de g√©rer les contenus 
de type ¬´ News ¬ª.
<br/>

Une **News** aura un id, un titre, une courte description, un contenu, un auteur, 
un statut de publication, une date et heure de cr√©ation 
(par d√©faut la date syst√®me au moment de la cr√©ation de l'instance), 
une date et heure ultime de p√©remption (un mois plus tard que la date de cr√©ation par d√©faut), 
une page associ√©e (null par d√©faut) ainsi qu'une position dans la page associ√©e. 
Le statut de publication d'une news peut actuellement prendre comme valeur :
-	¬´ hidden ¬ª
-	¬´ published ¬ª

<br/>

Seul un utilisateur authentifi√© pourra cr√©er des news.
La modification d'une news, tout comme la suppression d'une news ne pourra se faire que 
par son auteur.
<br/>

Est-ce qu'un auteur d'une news pourra associer une page √† sa news qui est d'un autre auteur ? 
Pour cet exercice, oui, l'association vers une page pourra se faire ind√©pendamment de 
l'auteur de la page.

La lecture d'une news, ou de toutes les news, pourra √™tre r√©alis√©e par n'importe quel utilisateur
anonyme ou authentifi√© pour les news dont le statut vaut ¬´ published ¬ª.
Pour les news dont le statut vaut ¬´ hidden ¬ª, seul leur auteur authentifi√© pourra les lire.
<br/>

On souhaite aussi rendre possible la lecture de toutes les news associ√©es √† une page ; 
pour ce faire la requ√™te devra indiquer la page pour laquelle on souhaite obtenir 
les news associ√©es. 

Tous les news dont le statut vaut ¬´ published ¬ª pourront √™tre lues par n'importe 
quel utilisateur (anonyme ou authentifi√©). 

Pour les news dont le statut vaut ¬´ hidden ¬ª, seul leur auteur authentifi√© pourra les lire.
<br/>

Veuillez d√©velopper une application JAX-RS mettant √† disposition les op√©rations 
d√©crites ci-dessus, en suivant les bonnes pratiques donn√©es dans ce module : abstraction 
de l'impl√©mentation, cr√©ation de ¬´ Factory ¬ª, injection de d√©pendances pour vos services‚Ä¶
<br/>

Dans un premier temps, veuillez formaliser les op√©rations associ√©es √† vos RESTful APIs 
sous forme d'un tableau dans un fichier **README.md**. 
Votre tableau devrait reprendre les conventions REST pr√©sent√©es au module 2  
([c) Rappel de conventions sur les RESTful APIs, authentification & autorisation](/modules/2#sectionC)).
<br/>
 
Lors de l'impl√©mentation de vos RESTful APIs, veuillez tester toutes les 
m√©thodes offertes par votre application JAX-RS √† l'aide d'un client l√©ger (HTTP client d'IntelliJ 
ou Rest Client de VS Code).
<br/>
<br/>

Quelques tips :
- Continuez le projet d√©velopp√© dans le cadre de l'Exercice 3.1. Il n'est pas n√©cessaire 
de cr√©er un nouveau projet.
- Pour la s√©rialisation de dates, nous vous conseillons ce lien : https://www.baeldung.com/jackson-serialize-dates.
Le plus simple est d'utiliser des instances de **Date** en les annotant via 
**@JsonFormat** si vous souhaitez avoir une date format√©e sous forme de String plut√¥t 
qu'un nombre long.
- Pour des valeurs par d√©faut de POJOs, n'h√©sitez pas √† utiliser le constructeur sans param√®tre :
    - La date de cr√©ation correspond √† la date √† l'instant de la cr√©ation de l'instance.
    - La date de p√©remption peut √™tre automatiquement mise √† un mois apr√®s la date de 
    cr√©ation en utilisant un objet de **Calendar** pour la conversion d'une date.

<br/>

**üç¨ Challenges optionnels** : 
- Nous vous proposons d'utiliser les vues JSON afin de ne jamais √©crire 
dans **db.json** toutes les infos li√©es √† la page associ√©e √† une news. On souhaiterait juste 
enregistrer l'id et le titre de la page.
- De plus, lorsque que des infos associ√©es √† une news sont renvoy√©es √† un client, 
on ne souhaite pas renvoyer toutes les infos de la page associ√©e √† la news. 
Dans ce cas-ci, on enregistra et renverra que ces deux propri√©t√©s d'une page associ√©e √† une news : 
**id** et **title**.
<br/>
