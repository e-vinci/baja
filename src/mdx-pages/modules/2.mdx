---
title: "Module 2 : JAX-RS & auths"
description: "Authentification & autorisation au sein de JAX-RS"
---

# Module 2 : JAX-RS & auths
Ce module vous offre le refactor d'une application JAX-RS tout en mettant en oeuvre le m√©canisme 
d'authentification et d'autorisation d'acc√®s aux op√©rations. 

Voici les sujets trait√©s :
- a) [Refactor d'une application JAX-RS](/modules/2#sectionA)
- b) [Configuration de l'application via un fichier .properties](/modules/2#sectionB)
- c) [Rappel de conventions sur les RESTful APIs, authentification & autorisation](/modules/2#sectionC)
- d) [Authentification & cr√©ation de token JWT](/modules/2#sectionD)
- e) [Utilisation de jbcrypt pour g√©rer les passwords](/modules/2#sectionE)
- f) [Autorisation JWT, filtres, providers & "Name binding"](/modules/2#sectionF)
- g) [Envoi de requ√™tes √† ses APIs](/modules/2#sectionG)
- h) [Gestion des requ√™tes contenant des objets JSON quelconques](/modules/2#sectionH)
- i) [Gestion des r√©ponses et s√©rialisation d'objets JSON quelconques](/modules/2#sectionI)
- j) [Exercice 2.1](/modules/2#sectionJ)

<br/>

# <a id="sectionA"></a>a) Refactor d'une application JAX-RS
## a.1) Refactor g√©n√©ral
Dans le Module 1, nous avons d√©velopp√© ensemble une RESTful API permettant de g√©rer des films.

Nous allons maintenant faire un refactor de cette application afin de mieux architecturer le code.
Voici les motivations pour r√©architecturer l'API :
1. Souhait de ne pas mixer le code associ√© √† la pr√©sentation des ressources, c'est-√†-dire le code 
s'occupant des r√©ponses aux requ√™tes clients, au code associ√© √† la gestion des donn√©es ;
on veut pouvoir mettre √† jour la couche d'acc√®s aux donn√©es sans devoir mettre √† jour les Root Ressources.
2. La partie business de l'application, en d'autres mots la logique d'acc√®s aux op√©rations sur les 
donn√©es, ne doit pas √™tre s√©par√©e de la gestion des donn√©es.
3. On veut pouvoir rapidement distinguer certaines parties de code : les objets du domaine, le main,  
les op√©rations offertes sur les ressources, les utilitaires, la logique d'acc√®s 
aux op√©rations sur les donn√©es et la gestion des donn√©es.

<br/>

Pour ce faire, veuillez cr√©er ces packages au sein de votre API g√©rant les films :
- **api** : s'occupera des Root Resources et donc de la pr√©sentation des ressources aux clients.
- **domain** : inclura tous les objets du domaines, les sacs de donn√©es.
- **main** : g√®re le d√©marrage de l'application JAX-RS.
- **services** : permet de traiter de la logique d'acc√®s aux op√©rations sur les donn√©es et la gestion de 
ces donn√©es.
- **utils** : traite des morceaux de code r√©utilisables sur potentiellement toutes les applications 
JAX-RS (gestion de la config par exemple).

<br/>

Veuillez d√©placer vos classes dans les bons packages. 
La classe **Json** est √† reprendre actuellement au sein du package **services**.
<br/>

Au sein du package **services**, veuillez cr√©er une nouvelle classe **FilmDataService** qui 
s'occupera de la logique et de l'acc√®s aux donn√©es en faisant appel aux m√©thodes de la classe **Json**.
Voici le code de **FilmDataService** :
```java
package be.vinci.services;

import be.vinci.domain.Film;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import org.apache.commons.text.StringEscapeUtils;

import java.util.List;

public class FilmDataService {
    public List<Film> getAll(int minimumDuration) {
        var films = Json.parse();
        if (minimumDuration != -1) {
            List<Film> filmsFiltered = films.stream().filter(film -> film.getDuration() >= minimumDuration)
                    .toList();
            return filmsFiltered;
        }
        return films;
    }


    public Film getOne(int id) {
        var films = Json.parse();
        Film filmFound = films.stream().filter(film -> film.getId() == id).findAny().orElse(null);
        return filmFound;
    }

    public Film createOne(Film film) {
        var films = Json.parse();
        film.setId(nextFilmId());
        film.setTitle(StringEscapeUtils.escapeHtml4(film.getTitle()));
        film.setLink(StringEscapeUtils.escapeHtml4(film.getLink()));
        films.add(film);
        Json.serialize(films);
        return film;
    }


    public Film deleteOne(int id) {
        var films = Json.parse();
        Film filmToDelete = films.stream().filter(film -> film.getId() == id).findAny().orElse(null);
        films.remove(filmToDelete);
        Json.serialize(films);
        return filmToDelete;
    }

    public Film updateOne(Film film, int id) {
        var films = Json.parse();
        Film filmToUpdate = films.stream().filter(f -> f.getId() == id).findAny().orElse(null);
        film.setId(id);
        film.setTitle(StringEscapeUtils.escapeHtml4(film.getTitle()));
        film.setLink(StringEscapeUtils.escapeHtml4(film.getLink()));
        films.remove(film); // thanks to equals(), films is found via its id
        films.add(film);
        Json.serialize(films);
        return film;
    }

    public int nextFilmId() {
        var films = Json.parse();
        if (films.size() == 0)
            return 1;
        return films.get(films.size() - 1).getId() + 1;
    }
}

```
<br/>

Dans le **Main**, faites en sorte de d√©couvrir les ressources que dans le package **api** :
```java {1}
final ResourceConfig rc = new ResourceConfig().packages("be.vinci.api");
```
<br/>

Dans **FilmResource**, cr√©ez une instance de **FilmDataService** et faites appel aux m√©thodes offertes par vos services :
```java numbered {5,10,18,32,42,57}
@Singleton
@Path("films")
public class FilmResource {

    private FilmDataService myFilmDataService = new FilmDataService();

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public List<Film> getAll(@DefaultValue("-1") @QueryParam("minimum-duration") int minimumDuration) {
        return myFilmDataService.getAll(minimumDuration);
    }


    @GET
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Film getOne(@PathParam("id") int id) {
        Film filmFound = myFilmDataService.getOne(id);
        if (filmFound == null)
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity("Ressource not found").type("text/plain").build());
        return filmFound;
    }

    @POST
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    public Film createOne(Film film) {
        if (film == null || film.getTitle() == null || film.getTitle().isBlank())
            throw new WebApplicationException(
                    Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
        return myFilmDataService.createOne(film);
    }

    @DELETE
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Film deleteOne(@PathParam("id") int id) {
        if (id == 0) // default value of an integer => has not been initialized
            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory id info")
                    .type("text/plain").build());
        Film deletedFilm = myFilmDataService.deleteOne(id);
        if (deletedFilm == null)
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity("Ressource not found").type("text/plain").build());
        return deletedFilm;
    }

    @PUT
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    public Film updateOne(Film film, @PathParam("id") int id) {
        if (id == 0 || film == null || film.getTitle() == null || film.getTitle().isBlank())
            throw new WebApplicationException(
                    Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
        Film updatedFilm = myFilmDataService.updateOne(film, id);
        if (updatedFilm == null)
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity("Ressource not found").type("text/plain").build());
        return updatedFilm;
    }
}
```
<br/>

Veuillez ex√©cuter et tester l'application pour vous assurer que celle-ci rende le m√™me service
que pr√©c√©demment.

<br/>

## a.2) Cr√©ation d'un utilitaire utile pour tous les services de donn√©es
La classe **Json** actuellement ne parse que des donn√©es vers le type **Film**.

Or on souhaiterait pouvoir charger n'importe quelle collection de donn√©es (pour n'importe quel type de ressources : des films, des textes...) et √©crire cela pour retourner une **`List<T>`** (une liste param√©tr√©e vers le type pass√© √† la classe g√©n√©rique **Json**) :
```java
return jsonMapper.readerForListOf(type).readValue(collection);
```
<br/>

On aimerait donc faire en sorte que **type**, dans le code donn√© ci-dessus, valent le type
pass√© √† une classe g√©n√©rique. Ca serait en fait le type **T** pass√© √† la classe **`Json<T>`**. La difficult√© pour y arriver, c'est que les "generics" en Java 
sont principalement d√©termin√©s √† la compilation. Cela signifie que l'information est perdue √† 
l'ex√©cution (le type param√©tr√© **T** est un **Object**). 
Pour obtenir l'information associ√© au type pass√© √† la classe g√©n√©rique, lors de l'ex√©cution,
il faut ajouter un argument √† une fonction.

Ici, on a choisi d'ajouter le type au constructeur.

Veuillez cr√©er le package **utils** au sein du package **services**.  
Voici le code mis √† jour de la classe **Json** pour la rendre g√©n√©rique afin de la param√©trer sur base du type associ√© aux ressources : 
```java numbered {1,6,10-12,15,41,49,51,53,56}
public class Json<T> {

    private static final String DB_FILE_PATH = Config.getProperty("DatabaseFilePath");
    private static Path pathToDb = Paths.get(DB_FILE_PATH);
    private final static ObjectMapper jsonMapper = new ObjectMapper();
    private Class<T> type ;

    // Java generics are mostly compile time, this means that the type information is lost at runtime.
    // To get the type information at runtime you have to add it as an argument of the constructor.
    public Json(Class<T> type){
        this.type = type;
    }


    public void serialize(List<T> items, String collectionName) {
        try {
            // if no DB file, write a new collection to a new db file
            if (!Files.exists(pathToDb)) {
                // Create an object and add a JSON array as POJO, e.g. { items:[...]}
                ObjectNode newCollection = jsonMapper.createObjectNode().putPOJO(collectionName, items);
                jsonMapper.writeValue(pathToDb.toFile(), newCollection); // write the JSON Object in the DB file
                return;
            }
            // get all collections : can be read as generic JsonNode, if it can be Object or Array;
            JsonNode allCollections = jsonMapper.readTree(pathToDb.toFile()); // e.g. { users:[...], items:[...]}
            // remove current collection, e.g. remove the array of items
            if (allCollections.has(collectionName)) {
                ((ObjectNode) allCollections).remove(collectionName); //e.g. it leaves { users:[...]}
            }
            // Prepare a JSON array from the list of POJOs for the collection to be updated, e.g. [{"film1",...}, ...]
            ArrayNode updatedCollection = jsonMapper.valueToTree(items);
            // Add the JSON array in allCollections, e.g. : { users:[...], items:[...]}
            ((ObjectNode) allCollections).putArray(collectionName).addAll(updatedCollection);
            // write to the db file allCollections
            jsonMapper.writeValue(pathToDb.toFile(), allCollections);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public List<T> parse(String collectionName) {
        try {
            // get allCollections
            JsonNode node = jsonMapper.readTree(pathToDb.toFile());
            // accessing value of the specified field of an object node,
            // e.g. the JSON array within "items" field of { users:[...], items:[...]}
            JsonNode collection = node.get(collectionName);
            if (collection == null) // Send an empty list if there is not the requested collection
                return (List<T>) new ArrayList<T>();
            // convert the JsonNode to a List of POJOs & return it
            return jsonMapper.readerForListOf(type).readValue(collection);
        } catch (FileNotFoundException e) {
            return (List<T>) new ArrayList<T>(); // send an empty list if there is no db file
        } catch (IOException e) {
            e.printStackTrace();
            return (List<T>) new ArrayList<T>();
        }
    }

}
```
<br/>

Il faut aussi mettre √† jour **FilmDataService** afin de param√©trer l'appel aux m√©thodes de la 
classe **Json** :
```java numbered {3-4,8,20,26,31,37,40,45,52,57}
public class FilmDataService {

  private static final String COLLECTION_NAME = "films";
  private static Json<Film> jsonDB = new Json<>(Film.class);


  public List<Film> getAll(int minimumDuration) {
    var films = jsonDB.parse(COLLECTION_NAME);
    if (minimumDuration != -1) {
      List<Film> filmsFiltered = films.stream()
          .filter(film -> film.getDuration() >= minimumDuration)
          .toList();
      return filmsFiltered;
    }
    return films;
  }


  public Film getOne(int id) {
    var films = jsonDB.parse(COLLECTION_NAME);
    Film filmFound = films.stream().filter(film -> film.getId() == id).findAny().orElse(null);
    return filmFound;
  }

  public Film createOne(Film film) {
    var films = jsonDB.parse(COLLECTION_NAME);
    film.setId(nextFilmId());
    film.setTitle(StringEscapeUtils.escapeHtml4(film.getTitle()));
    film.setLink(StringEscapeUtils.escapeHtml4(film.getLink()));
    films.add(film);
    jsonDB.serialize(films, COLLECTION_NAME);
    return film;
  }


  public Film deleteOne(int id) {
    var films = jsonDB.parse(COLLECTION_NAME);
    Film filmToDelete = films.stream().filter(film -> film.getId() == id).findAny().orElse(null);
    films.remove(filmToDelete);
    jsonDB.serialize(films, COLLECTION_NAME);
    return filmToDelete;
  }

  public Film updateOne(Film film, int id) {
    var films = jsonDB.parse(COLLECTION_NAME);
    Film filmToUpdate = films.stream().filter(f -> f.getId() == id).findAny().orElse(null);
    film.setId(id);
    film.setTitle(StringEscapeUtils.escapeHtml4(film.getTitle()));
    film.setLink(StringEscapeUtils.escapeHtml4(film.getLink()));
    films.remove(film); // thanks to equals(), films is found via its id
    films.add(film);
    jsonDB.serialize(films, COLLECTION_NAME);
    return film;
  }

  public int nextFilmId() {
    var films = jsonDB.parse(COLLECTION_NAME);
      if (films.size() == 0) {
          return 1;
      }
    return films.get(films.size() - 1).getId() + 1;
  }
}
```
<br/>

Veuillez ex√©cuter et tester votre application JAX-RS pour vous assurer que celle-ci est bien 
fonctionnelle.

<br/>

# <a id="sectionB"></a>b) Configuration de l'application via un fichier .properties
Une bonne pratique est de rendre configurable son application Java via un fichier **.properties**.

Nous allons rendre cela possible en modifiant notre API de gestion de films.
Veuillez cr√©er la classe **Config** dans le package **utils** : 
```java
package be.vinci.utils;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

import jakarta.ws.rs.WebApplicationException;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;

public class Config {

    private static Properties props;

    public static void load(String file) {
        props = new Properties();
        try (InputStream input = new FileInputStream(file)) {
            props.load(input);
        } catch (IOException e) {
            throw new WebApplicationException(
                    Response.status(Status.INTERNAL_SERVER_ERROR).entity(e.getMessage()).type("text/plain").build());
        }
    }

    public static String getProperty(String key) {
        return props.getProperty(key);
    }

    public static Integer getIntProperty(String key) {
        return Integer.parseInt(props.getProperty(key));
    }

    public static boolean getBoolProperty(String key) {
        return Boolean.parseBoolean(props.getProperty(key));
    }

}
```
<br/>

Cette classe **Config** permet de charger toutes les param√®tres de configuration de l'application.
<br/>

Les param√®tres de configuration de l'application, ou propri√©t√©s, sont √† ajouter manuellement 
dans un fichier **.properties**. Ce fichier contient des propri√©t√©s sous forme de **key=value**, 
comme par exemple l'URL du serveur int√©gr√© √† l'application JAX-RS.

Veuillez ajouter le fichier **dev.properties** √† la racine de votre projet :
```
BaseUri=http://localhost:8080/
DatabaseFilePath=db.json
```
<br/>

Pour que les propri√©t√©s soient disponibles dans tout le programme, le chargement des propri√©t√©s 
se trouvant dans le fichier **/dev.properties** se fait dans le **Main**, au d√©but de l'ex√©cution 
de la m√©thode **main**, ou m√™me avant l'ex√©cution de cette m√©thode.
Vous pourriez ajouter cette ligne dans la fonction **main**, avant de cr√©er le serveur Http :
```java
Config.load("dev.properties");
```
<br/>

Mais nous vous proposons d'utiliser un initialiseur "static" qui sera appel√© avant la m√©thode 
**main**. Veuillez mettre √† jour votre classe **Main** en ajoutant :
```java {2-4}
public class Main {
    static{
        Config.load("dev.properties");
    }
```
<br/>

L'utilisation d'une propri√©t√©, comme par exemple l'URL du serveur int√©gr√© √† l'application JAX-RS,
se fait via l'appel de **getProperty** de **Config** (ou **getIntProperty** ou **getBoolProperty**). 

Veuillez mettre √† jour la classe **Main** :
```java {6}
public class Main {
    static{
        Config.load("dev.properties");
    }
    // Base URI the Grizzly HTTP server will listen on
    public static final String BASE_URI = Config.getProperty("BaseUri");
```
<br/>

Veuillez aussi mettre √† jour la classe **Json** pour utiliser la propri√©t√© associ√©e au chemin
vers le fichier **db.json** :
```java {2}
public class Json<T> {
    private static final String DB_FILE_PATH = Config.getProperty("DatabaseFilePath");
```
<br/>

# <a id="sectionC"></a>c) Rappel de conventions sur les RESTful APIs, authentification & autorisation
## c.1) Conventions sur les RESTful APIs
Pour rappel, un RESTful web service, ou RESTful API, met √† disposition des op√©rations 
sur des ressources. Ces op√©rations seront disponibles via des requ√™tes http associ√©es √† des 
URLs construites selon les conventions RESTful.
<br/>

Certaines op√©rations sont prot√©g√©es par des tokens JWT. 
Ainsi, tout client souhaitant acc√©der √† ces op√©rations devra fournir un token dans le header 
de la requ√™te.
Le client devra donc m√©moriser le token re√ßu lors de son enregistrement (**auths/register**) ou 
lors de son login (**auths/login**) afin de le fournir √† chaque requ√™te vers une op√©ration 
prot√©g√©e.

Voici les tableaux formalisant toutes les op√©rations associ√©es √† la RESTful API permettant de g√©rer 
des films :

<br/>

##### Tableau 1 : op√©rations sur les ressources de type "Authentification"
| URI | M√©thode HTTP | Auths? | Op√©ration |
|---|---|---|---|
| **auths/login** | POST | Non | V√©rifier les ¬´ credentials ¬ª d'un User et renvoyer le User et un token JWT s'ils sont OK |
| **auths/register** | POST | Non | Cr√©er une ressource User et un token JWT et les renvoyer |

<br/>

##### Tableau 2 : op√©rations sur les ressources de type "Film"
| URI | M√©thode HTTP | Auths? | Op√©ration |
|---|---|---|---|
| **films** | GET | Non | READ ALL : Lire toutes les ressources de la collection |
| **films?minimumduration=value** | GET | Non | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **films/{id}** | GET | Non | READ ONE : Lire la ressource identifi√©e |
| **films** | POST | JWT | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| **films/{id}** | DELETE | JWT | DELETE ONE : Effacer la ressource identifi√©e |
| **films/{id}** | PUT | JWT | UPDATE ONE : Replacer l'enti√®ret√© de la ressource par les donn√©es de la requ√™te |

<br/>

## c.2) JWT authentification et autorisation : concepts g√©n√©raux
Les JWT sont parfaits pour la cr√©ation de RESTful APIs, car ils permettent de mettre en place 
un m√©canisme d'authentification et autorisation ¬´ stateless ¬ª pour le backend.
<br/>

Le client va s'authentifier et donc obtenir un JWT g√©n√©r√© par l'API lors de son enregistrement 
(**auths/register**) ou lors de son login (**auths/login**).

Le JWT g√©n√©r√© par l'API contient 3 parties :
-	Un **header** : il est encod√© en base64 indiquant l'algorithme de la signature du token.
-	Un **payload** : il est encod√© en base64, il contient g√©n√©ralement des donn√©es permettant 
d'identifier l'utilisateur faisant la requ√™te. Ces donn√©es ne sont pas secr√®tes 
(le payload n'est pas crypt√© !)
-	Une **signature** : elle est hach√©e selon l'algorithme sp√©cifi√© dans le header. 
La signature permet de v√©rifier que le token n'a pas √©t√© modifi√©, et donc, 
de mettre en place un m√©canisme d'autorisation d'acc√®s aux op√©rations d'une API.

<br/>

Tout client souhaitant acc√©der √† des op√©rations n√©cessitant une autorisation via JWT devra fournir 
un JWT dans le header de sa requ√™te.
Pour ce faire, le client m√©morisera g√©n√©ralement le JWT re√ßu lors de son authentification.
Typiquement, le JWT re√ßu par un client est enregistr√© dans le Web Storage de son browser ou dans un cookie.

<br/>

# <a id="sectionD"></a>d) Authentification et cr√©ation de token JWT
## d.1) Ajout de la d√©pendance java-jwt
Tant pour la cr√©ation que la v√©rification d'un token, nous utiliserons la librairie java-jwt :
https://github.com/auth0/java-jwt

Pour utiliser cette librairie, ajoutez une d√©pendance √† **java-jwt** :
- Via IntelliJ : 
  - cliquez au sein de votre fichier **pom.xml** : **Code**, **Generate...**, **Add dependency...**
  - tapez : **java-jwt**
  - Installez les d√©pendances Maven en cliquant sur le bouton repr√©sentant "**Load Maven Changes**"
  - NB : si IntelliJ ne trouve pas votre d√©pendance, et que le num√©ro de version est mis en rouge
  dans **pom.xml**, vous pouvez probablement r√©soudre cela en faisant un clic droit sur votre 
  **pom.xml**, **Maven**, **Reload project**.
- Si vous n'avez pas IntelliJ, ajoutez cela au sein de **pom.xml** puis forcer l'installation des d√©pendances :
```markup
<dependency>
            <groupId>com.auth0</groupId>
            <artifactId>java-jwt</artifactId>
            <version>4.2.2</version>
</dependency>
```
<br/>

## d.2) Cr√©ation du token JWT
### d.2.1) Introduction
Un token JWT doit √™tre cr√©√© lors de l'authentification d'un utilisateur, au login ou √† 
l'enregistrement de celui-ci.

Nous allons donc cr√©er les op√©rations **login** et **register** pour des ressources de type **User**.
<br/>

Pour ce faire, voici les √©tapes que nous allons suivre :
- Ajout d'une propri√©t√© pour g√©rer le secret associ√© √† la signature des tokens.
- Cr√©ation d'une classe **User** qui va permettre de s√©rialiser les donn√©es du monde Java vers
le monde JSON.
- Cr√©ation d'une classe **UserDataService** qui va permettre de g√©rer les donn√©es associ√©es aux 
utilisateurs et qui va offrir les services d'acc√®s aux donn√©es et la logique pour le **login** 
et le **register**.
- Cr√©ation d'une Root Resource **AuthsResource** qui va s'occuper de g√©rer la pr√©sentation des 
ressources (login & register) aux clients.
- Am√©lioration de la classe **Json** qui s'occupe de la persistance des donn√©es afin que l'on 
puisse parser n'importe quelle collection de donn√©es. 
- Test des op√©rations de **login** et **register**.

<br/>

### d.2.2) Propri√©t√© associ√©e au secret utilis√© pour la signature
Veuillez ajouter le secret permettant de signer les token au sein de votre fichier **dev.properties** :
```text {3}
BaseUri=http://localhost:8080/
DatabaseFilePath=db.json
JWTSecret=ilovefilms
```
<br/>

### d.2.3) Cr√©ation des objets du domaine 
Veuillez ajouter la classe **User** au package **domain** :
```java
package be.vinci.domain;

public class User {

    private int id;

    private String login;

    private String password;

    public String getLogin() {
        return login;
    }

    public void setLogin(String login) {
        this.login = login;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public boolean checkPassword(String password) {
        return this.password.equals(password);
    }

    @Override
    public String toString() {
        return "{id:" + id + ", login:" + login + ", password:" + password + "}";
    }

}
```
<br/>

### d.2.4) Cr√©ation du service de donn√©es associ√© aux utilisateurs
Nous souhaitons cr√©er une classe **UserDataService** qui va permettre :
- de g√©rer les donn√©es associ√©es aux utilisateurs ;
- d'offrir les cas d'utilisation **login** et **register**.

<br/>

Veuillez ajouter cette classe dans le package **services** :
```java numbered {16,57-58,84-85}
package be.vinci.services;

import be.vinci.domain.User;
import be.vinci.services.utils.Json;
import be.vinci.utils.Config;
import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.util.List;

public class UserDataService {
    private static final String COLLECTION_NAME = "users";
    private static Json<User> jsonDB = new Json<>(User.class);
    private final Algorithm jwtAlgorithm = Algorithm.HMAC256(Config.getProperty("JWTSecret"));
    private final ObjectMapper jsonMapper = new ObjectMapper();


    public List<User> getAll() {
        var items = jsonDB.parse(COLLECTION_NAME);
        return items;
    }


    public User getOne(int id) {
        var items = jsonDB.parse(COLLECTION_NAME);
        return items.stream().filter(item -> item.getId() == id).findAny().orElse(null);
    }

    public User getOne(String login) {
        var items = jsonDB.parse(COLLECTION_NAME);
        return items.stream().filter(item -> item.getLogin().equals(login)).findAny().orElse(null);
    }

    public User createOne(User item) {
        var items = jsonDB.parse(COLLECTION_NAME);
        item.setId(nextItemId());
        items.add(item);
        jsonDB.serialize(items, COLLECTION_NAME);
        return item;
    }

    public int nextItemId() {
        var items = jsonDB.parse(COLLECTION_NAME);
        if (items.size() == 0)
            return 1;
        return items.get(items.size() - 1).getId() + 1;
    }

    public ObjectNode login(String login, String password) {
        User user = getOne(login);
        if (user == null || !user.checkPassword(password))
            return null;
        String token;
        try {
            token = JWT.create().withIssuer("auth0")
                    .withClaim("user", user.getId()).sign(this.jwtAlgorithm);
            ObjectNode publicUser = jsonMapper.createObjectNode()
                    .put("token", token)
                    .put("id", user.getId())
                    .put("login", user.getLogin());
            return publicUser;

        } catch (Exception e) {
            System.out.println("Unable to create token");
            return null;
        }
    }

    public ObjectNode register(String login, String password) {
        User tempUser = getOne(login);
        if (tempUser != null) // the user already exists !
            return null;
        tempUser = new User();
        tempUser.setLogin(login);
        tempUser.setPassword(password);

        User user = createOne(tempUser);
        if (user == null)
            return null;
        String token;
        try {
            token = JWT.create().withIssuer("auth0")
                    .withClaim("user", user.getId()).sign(this.jwtAlgorithm);
            ObjectNode publicUser = jsonMapper.createObjectNode()
                    .put("token", token)
                    .put("id", user.getId())
                    .put("login", user.getLogin());
            return publicUser;

        } catch (Exception e) {
            System.out.println("Unable to create token");
            return null;
        }
    }

}
```
<br/>

Voici quelques explications concernant les token (d'autres explications portant sur les param√®tres
de requ√™te et la pr√©paration des r√©ponses seront donn√©es plus tard) :
- ligne 16 : on configure l'algorithme qui sera utilis√© pour la signature du token sur base du 
secret se trouvant dans **dev.properties**
- lignes 57-58 & 84-85 : on g√©n√®re un token et l'on ajoute juste l'**id** de l'utilisateur 
dans le payload.

<br/>

### d.2.4) Cr√©ation de la Root Resource "User"
Veuillez ajouter cette classe dans le package **api** :
```java
package be.vinci.api;

import be.vinci.services.UserDataService;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import jakarta.inject.Singleton;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

@Singleton
@Path("/auths")
public class AuthsResource {

    private UserDataService myUserDataService = new UserDataService();

    @POST
    @Path("login")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public ObjectNode login(JsonNode json) {
        // Get and check credentials
        if (!json.hasNonNull("login") || !json.hasNonNull("password")) {
            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
                    .entity("login or password required").type("text/plain").build());
        }
        String login = json.get("login").asText();
        String password = json.get("password").asText();

        // Try to login
        ObjectNode publicUser = myUserDataService.login(login, password);
        if (publicUser == null) {
            throw new WebApplicationException(Response.status(Response.Status.UNAUTHORIZED)
                    .entity("Login or password incorrect").type(MediaType.TEXT_PLAIN)
                    .build());
        }
        return publicUser;

    }

    @POST
    @Path("register")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public ObjectNode register(JsonNode json) {
        // Get and check credentials
        if (!json.hasNonNull("login") || !json.hasNonNull("password")) {
            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
                    .entity("login or password required").type("text/plain").build());
        }
        String login = json.get("login").asText();
        String password = json.get("password").asText();

        // Try to login
        ObjectNode publicUser = myUserDataService.register(login, password);
        if (publicUser == null) {
            throw new WebApplicationException(Response.status(Response.Status.CONFLICT)
                    .entity("this resource already exists").type(MediaType.TEXT_PLAIN)
                    .build());
        }
        return publicUser;

    }

}
}
```
<br/>

Le service de donn√©es s'occupant des utilisateurs fournit, lors du login et du register, un **ObjectNode** qui contient l'id, le login et le token d'un utilisateur. 

<br/>

### d.2.5) Test des op√©rations de login et de register
Veuillez tester les deux nouvelles op√©rations ajout√©es.
Pour ce faire, √† l'aide d'InteliJ, ajoutez le fichier **users.http** √† votre module ou 
projet (dans le r√©pertoire **requests** par exemple) avec ces requ√™tes :
```http-requests
### Register one default user
POST {{baseUrl}}/auths/register
Content-Type: application/json

{
  "login":"james",
  "password":"password"
}

### Login with default user credentials
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
  "login":"james",
  "password":"password"
}

### Register john
POST {{baseUrl}}/auths/register
Content-Type: application/json

{
  "login":"john",
  "password":"123"
}

### Login with John credentials
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
  "login":"john",
  "password":"123"
}
```
<br/>

Il ne vous reste plus qu'√† ex√©cuter votre RESTful API et ex√©cuter les requ√™tes pour voir que l'API vous renvoie bien des tokens.

Si vous n'utilisez pas IntelliJ, mais plut√¥t VS Code, il suffit juste de rajouter la variable **baseUrl** √† votre script **auths.http**.
<br/>

# <a id="sectionE"></a>e) Utilisation de jbcrypt pour g√©rer les passwords
Tant pour hasher un password que pour le v√©rifier, nous utiliserons la librairie jbcrype :
https://www.mindrot.org/projects/jBCrypt/

Pour utiliser cette librairie, ajoutez une d√©pendance √† **jbcrypt** :
- Via IntelliJ : 
  - cliquez au sein de votre fichier **pom.xml** : **Code** (ou clic droit dans **pom.xml**), **Generate...**, **Add dependency...**
  - tapez : **jbcrypt**
  - Installez les d√©pendances Maven en cliquant sur le bouton repr√©sentant "**Load Maven Changes**"
  - NB : si IntelliJ ne trouve pas votre d√©pendance, et que le num√©ro de version est mis en rouge
  dans **pom.xml**, vous pouvez probablement r√©soudre cela en faisant un clic droit sur votre 
  **pom.xml**, **Maven**, **Reload project**.
- Si vous n'avez pas IntelliJ, ajoutez cela au sein de **pom.xml** puis forcer l'installation des d√©pendances :
```markup
<dependency>
            <groupId>org.mindrot</groupId>
            <artifactId>jbcrypt</artifactId>
            <version>0.4</version>
</dependency>
```
<br/>

Nous allons mettre √† jour la classe **User** afin d'offrir la fonction **hashPassword** et mettre √† jour la fonction **checkPassword** : 
```java
public boolean checkPassword(String password) {
    return BCrypt.checkpw(password, this.password);
}

public String hashPassword(String password) {
    return BCrypt.hashpw(password, BCrypt.gensalt());
}
```
<br/>

‚ö° Attention, maintenant que nous utilisons les passwords hach√©s, il faut supprimer l'ancienne base 
de donn√©e des utilisateurs. Vous devez soit effacer la collection **users** du fichier **db.json**,
soit vous pouvez aussi directement effacer le fichier **db.json**.
<br/>

Il ne reste plus qu'√† modifier l√©g√©rement **UserDataService** afin d'enregistrer les passwords 
hach√©s : veuillez mettre √† jour la ligne surlign√©e de la m√©thode **register** :
```java {7}
public ObjectNode register(String login, String password) {
        User tempUser = getOne(login);
        if (tempUser != null) // the user already exists !
            return null;
        tempUser = new User();
        tempUser.setLogin(login);
        tempUser.setPassword(tempUser.hashPassword(password));
```
<br/>

# <a id="sectionF"></a>f) Autorisation JWT, filtres, providers & "Name binding"
## f.1) V√©rification d'un token : concepts g√©n√©raux
La v√©rification d'un token n'est n√©cessaire que pour les op√©rations sur les ressources 
qui doivent √™tre prot√©g√©es (ou autoris√©es).

Le code g√©n√©rique pour v√©rifier un token est donn√© ici :
https://github.com/auth0/java-jwt#verify-a-token.
<br/>

Il serait peu int√©ressant de devoir r√©impl√©menter ce code pour chaque op√©ration n√©cessitant 
une autorisation JWT.
<br/>

Ce que nous souhaitons, c'est :
- Pouvoir annoter chaque m√©thode d'une Root Resource devant √™tre autoris√©e par JWT : 
nous choisissons l'annotation **@Authorize** pour notre API de gestion de films ;
- Appeler le morceau de code s'occupant de v√©rifier un JWT pour chaque m√©thode annot√©e de **@Authorize** :
    - si le JWT re√ßu au sein du header de la requ√™te est OK, nous nous occupons de charger 
    l'utilisateur ayant fait la requ√™te dans un container associ√© √† la requ√™te du client, 
    via la cl√© "user" ; ensuite, le code de la m√©thode annot√©e par **@Authorize** est ex√©cut√© ;
    - si le JWT re√ßu au sein du header n'est pas v√©rifi√© avec succ√®s, nous envoyons un code 
    d'erreur au client ; le code de la m√©thode annot√©e par **@Authorize** ne sera donc pas ex√©cut√©.

<br/>

NB : Pour certains d'entre vous, cela pourrait vous rappellera la cr√©ation et l'utilisation 
d'un middleware ¬´ authorize ¬ª dans le monde de Node.js / Express.
<br/>

Au sein d'une application JAX-RS, les filtres ¬´ serveurs ¬ª permettent de modifier 
les requ√™tes ou les r√©ponses, soit pour toutes les requ√™tes, soit pour seulement certaines 
m√©thodes‚Ä¶ 

La suite fournit un r√©sum√© de comment mettre en place un filtre ¬´ serveur ¬ª pour toutes 
les m√©thodes contenant une annotation personnelle, **@Authorize** dans la d√©mo.
<br/>

## f.2) Filtres, providers & ¬´ Name binding ¬ª
Il est possible de cr√©er toutes sortes de filtres pour modifier soit les requ√™tes,
soit les r√©ponses d'une application JAX-RS. 
<br/>

Si vous souhaitez des d√©tails en plus du r√©sum√© pr√©sent√© par la suite, les filtres sont expliqu√©s dans le manuel de Jersey : 
https://eclipse-ee4j.github.io/jersey.github.io/documentation/latest3x/filters-and-interceptors.html
<br/>

Les filtres ¬´ serveurs ¬ª sont illustr√© au sein de cette section via la mise en place 
d'un filtre de requ√™tes permettant principalement de filtrer toutes les requ√™tes qui 
ne seraient pas autoris√©es (lorsque le JWT re√ßu n'est pas valide).
<br/>

Afin d'ex√©cuter le traitement d'autorisation JWT pour chaque m√©thode annot√©e de **@Authorize**, 
nous allons utiliser un objet de type ¬´ filtre de requ√™te ¬ª qui h√©rite de **ContainerRequestFilter**.
<br/>

Veuillez ajouter un package **filters** au sein du package **api** et y cr√©er la classe 
**AuthorizationRequestFilter** :
```java
package be.vinci.api.filters;

import java.io.IOException;

import be.vinci.domain.User;
import be.vinci.services.UserDataService;
import be.vinci.utils.Config;
import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.auth0.jwt.interfaces.JWTVerifier;
import jakarta.inject.Singleton;
import jakarta.ws.rs.WebApplicationException;
import jakarta.ws.rs.container.ContainerRequestContext;
import jakarta.ws.rs.container.ContainerRequestFilter;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;
import jakarta.ws.rs.ext.Provider;

@Singleton
@Provider
@Authorize
public class AuthorizationRequestFilter implements ContainerRequestFilter {
    private final Algorithm jwtAlgorithm = Algorithm.HMAC256(Config.getProperty("JWTSecret"));
    private final JWTVerifier jwtVerifier = JWT.require(this.jwtAlgorithm).withIssuer("auth0").build();
    private UserDataService myUserDataService = new UserDataService();

    @Override
    public void filter(ContainerRequestContext requestContext) throws IOException {
        String token = requestContext.getHeaderString("Authorization");
        if (token == null) {
            requestContext.abortWith(Response.status(Response.Status.UNAUTHORIZED)
                    .entity("A token is needed to access this resource").build());
        } else {
            DecodedJWT decodedToken = null;
            try {
                decodedToken = this.jwtVerifier.verify(token);
            } catch (Exception e) {
                throw new WebApplicationException(Response.status(Status.UNAUTHORIZED)
                        .entity("Malformed token : " + e.getMessage()).type("text/plain").build());
            }
            User authenticatedUser = myUserDataService.getOne(decodedToken.getClaim("user").asInt());
            if (authenticatedUser == null) {
                requestContext.abortWith(Response.status(Status.FORBIDDEN)
                        .entity("You are forbidden to access this resource").build());
            }

            requestContext.setProperty("user", authenticatedUser);
        }
    }

}
```
<br/>

**AuthorizationRequestFilter** va v√©rifier le JWT : 
- S'il n'est pas OK, la requ√™te est ¬´ avort√©e ¬ª en appelant **abortWith** et en 
fournissant le code d'erreur ainsi qu'un message d'erreur au client. 
- Si le JWT est OK, le claim "user" mis dans le payload du JWT, 
qui en fait est l'id de l'utilisateur, est utilis√© pour ajouter l'utilisateur √† la requ√™te 
( l'utilisateur est r√©cup√©r√© en faisant appel √† la m√©thode **getOne** du service des donn√©es 
des utilisateurs) sous la cl√© **user**.  
Ensuite, la m√©thode de la ressource annot√©e par **@Authorize** est ex√©cut√©e, afin de pr√©parer la r√©ponse au client.

<br/>

La notion de **provider** est d√©finie dans la sp√©cification de JAX-RS : 
https://jakarta.ee/specifications/restful-ws/3.0/jakarta-restful-ws-spec-3.0.html#providers. 

<br/>

En r√©sum√©, un **provider** permet de filtrer les requ√™tes, convertir des repr√©sentations 
(XML, JSON‚Ä¶) vers des objets Java, mapper des exceptions √† des r√©ponses‚Ä¶ 

Il existe de nombreux providers pr√©d√©finis qui sont fournis dans Jersey. 

L'annotation **@Provider** permet de fournir notre propre impl√©mentation d'un provider, 
de la rendre disponible √† l'ex√©cution √† notre application JAX-RS.
<br/>

Un filtre peut √™tre li√© √† un nom, ce que l'on appelle ¬´ **Name binding** ¬ª. 

A l'ex√©cution d'une application JAX-RS, on pourra sp√©cifier que le filtre sera ex√©cut√© 
seulement pour certaines m√©thodes.

NB : les filtres peuvent ne pas √™tre limit√©s, on les appelle alors filtre globaux.
<br/>

Nous allons d√©finir une annotation de type ¬´ **Name binding** ¬ª via **@NameBinding**.

Veuillez cr√©er l'annotation **Authorize** au sein du package **filters** :
```java
package be.vinci.api.filters;

import jakarta.ws.rs.NameBinding;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@NameBinding
@Retention(RetentionPolicy.RUNTIME)
public @interface Authorize {
}
```
<br/>

C'est gr√¢ce √† cette annotation qui a √©t√© d√©finie que **AuthorizationRequestFilter** 
ne s'ex√©cutera que pour les m√©thodes annot√©es de **@Authorize**.
<br/>

Au sein de **FilmResource**, il nous reste donc √† annoter les op√©rations d'√©criture de notre API de gestion de films afin de 
les prot√©ger par une autorisation JWT :
```java numbered {43,54,70}
package be.vinci.api;

import be.vinci.api.filters.Authorize;
import be.vinci.domain.Film;
import be.vinci.domain.User;
import be.vinci.services.FilmDataService;
import jakarta.inject.Singleton;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import org.glassfish.jersey.server.ContainerRequest;

import java.util.List;

@Singleton
@Path("films")
public class FilmResource {

    private FilmDataService myFilmDataService = new FilmDataService();

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public List<Film> getAll(@DefaultValue("-1") @QueryParam("minimum-duration") int minimumDuration) {
        return myFilmDataService.getAll(minimumDuration);
    }


    @GET
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Film getOne(@PathParam("id") int id) {
        Film filmFound = myFilmDataService.getOne(id);
        if (filmFound == null)
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity("Ressource not found").type("text/plain").build());
        return filmFound;
    }

    @POST
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    @Authorize
    public Film createOne(Film film, @Context ContainerRequest request) {
        if (film == null || film.getTitle() == null || film.getTitle().isBlank())
            throw new WebApplicationException(
                    Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
        return myFilmDataService.createOne(film);
    }

    @DELETE
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    @Authorize
    public Film deleteOne(@PathParam("id") int id) {
        if (id == 0) // default value of an integer => has not been initialized
            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory id info")
                    .type("text/plain").build());
        Film deletedFilm = myFilmDataService.deleteOne(id);
        if (deletedFilm == null)
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity("Ressource not found").type("text/plain").build());
        return deletedFilm;
    }

    @PUT
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    @Authorize
    public Film updateOne(Film film, @PathParam("id") int id) {
        if (id == 0 || film == null || film.getTitle() == null || film.getTitle().isBlank())
            throw new WebApplicationException(
                    Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
        Film updatedFilm = myFilmDataService.updateOne(film, id);
        if (updatedFilm == null)
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity("Ressource not found").type("text/plain").build());
        return updatedFilm;
    }


}
```
<br/>


Comment peut-on r√©cup√©rer l'objet **user** mis dans la requ√™te par le 
**AuthorizationRequestFilter** ?
<br/>

Voici un exemple en modifiant la m√©thode **createOne** de **FilmResource** :
```java {5-7}
@POST
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@Authorize
public Film createOne(Film film, @Context ContainerRequest request) {
    User authenticatedUser = (User) request.getProperty("user");
    System.out.println("A new film is added by " + authenticatedUser.getLogin() );
    if (film == null || film.getTitle() == null || film.getTitle().isBlank())
        throw new WebApplicationException(
                Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
    return myFilmDataService.createOne(film);
}
```
<br/>

C'est l'appel de **getProperty** sur un **ContainerRequest** qui permet de r√©cup√©rer 
l'objet pr√©par√© lors du traitement d'autorisation JWT (fait dans le filtre).
<br/>

üí≠  Pourquoi ajouter de l'information au sein d'une requ√™te ?  
Imaginez faire un appel √† une base de donn√©e lorsque vous voulez v√©rifier qu'un utilisateur est bien authentifi√©, gr√¢ce √† votre filtre. Une fois le code du filtre ex√©cut√©, vous aller r√©aliser l'op√©ration demand√©e par le client. Il se peut que cette op√©ration n√©cessite les donn√©es de l'utilisateur authentifi√©. Allez vous √† nouveau faire un appel √† la base de donn√©es ? H√© bien non, vous √©conomisez cet appel √† la base de donn√©es car les donn√©es de l'utilisateur authentifi√© sont disponibles dans le contexte de la requ√™te.
<br/>

# <a id="sectionG"></a>g) Envoi des requ√™tes √† son API et JWT
## g.1) Test de son API avec JWT
Dans le cadre de ce cours, vous ne devez pas d√©velopper de frontend (par exemple en HTML / 
JavaScript / CSS) pour tester vos APIs. Cela prendrait trop de temps. 

Nous utilisons donc des clients l√©gers permettant de faire des requ√™tes √† nos APIs.

Comme nous vous encourageons √† utiliser IntelliJ pour d√©velopper votre code Java, il est probablement 
plus ais√© de rester au sein du m√™me environnement de d√©veloppement en utilisant le client HTTP 
d'IntelliJ.
<br/>

## g.2) HTTP Client d'IntelliJ avec des JWT
IntelliJ permet d'ajouter des scripts associ√©s aux r√©ponses de cette fa√ßon :
```text
GET host/api/test

> {%
// Response Handler Script
...
%}
```
<br/>

Les scripts g√©rant les r√©ponses aux requ√™tes peuvent acc√©der √† deux objets :
- **client** : permet d'enregistrer des donn√©es de session dans **client.global**.
Chaque variable que l'on sauve dans **client.global** en tant que **variable_name**, 
en appelant la m√©thode **set**, sera accessible dans les requ√™tes futures via **{{variable_name}}**.
- **response** : contient les infos de la r√©ponse √† la requ√™te (type, status, body...)

<br/>

Voici le code permettant de tester l'API de gestion des films :

```text
### Read All films
GET {{baseUrl}}/films

### Login the default user
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
  "login":"james",
  "password":"password"
}

> {%
client.global.set("jamesToken", response.body.token);
%}


### Create One film
POST {{baseUrl}}/films
Content-Type: application/json
Authorization: {{jamesToken}}

{
  "title": "Venom: Let There Be Carnage",
  "duration": 9,
  "budget": 110,
  "link": "https://en.wikipedia.org/wiki/Venom:_Let_There_Be_Carnage"
}

### Delete One film
DELETE {{baseUrl}}/films/5
Authorization: {{jamesToken}}

### Update One film
PUT {{baseUrl}}/films/4
Content-Type: application/json
Authorization: {{jamesToken}}

{
  "title": "Venom: Let There Be Carnage",
  "duration": 97,
  "budget": 110,
  "link": "https://en.wikipedia.org/wiki/Venom:_Let_There_Be_Carnage"
}

### Create One film with dangerous characters
POST {{baseUrl}}/films
Content-Type: application/json
Authorization: {{jamesToken}}

{
  "title": "<img src=\"#\" onerror=\"alert('You have been hacked !')\">",
  "duration": 9,
  "budget": 110,
  "link": "https://en.wikipedia.org/wiki/Venom:_Let_There_Be_Carnage"
}
```

<br/>

Plus d'information sur la gestion des r√©ponses aux requ√™tes via le client HTTP d'IntelliJ :
https://www.jetbrains.com/help/idea/http-client-in-product-code-editor.html#using-response-handler-scripts

<br/>

## g.3) REST Client sous VS Code & JWT
Quelques notions pour utiliser REST Client avec des JWT :
- Il est possible de cr√©er des ¬´ **Request Variables** ¬ª afin de r√©cup√©rer la r√©ponse associ√©e 
√† une requ√™te au sein d'une variable.
- On va donc pouvoir r√©cup√©rer le token, suite √† une requ√™te d'authentification, 
au sein d'une ¬´ **Request Variable** ¬ª, pour ensuite fournir ce token dans le 
¬´ **Authorization header** ¬ª de toutes les requ√™tes demandant une autorisation JWT.

<br/>

Voici le script permettant de tester les op√©rations sur les films :

```http-requests
@baseUrl = http://localhost:8080

### Login the default user & define a Request Variable
# @name james
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
  "login":"james",
  "password":"password"
}
### get the james' token in a File Variable
@jamesToken = {{james.response.body.token}}

### Create One film
POST {{baseUrl}}/films
Content-Type: application/json
Authorization: {{jamesToken}}

{
  "title" : "Venom: Let There Be Carnage",
  "duration" : 97,
  "budget" : 110,
  "link" : "https://en.wikipedia.org/wiki/Venom:_Let_There_Be_Carnage"
}

### Read All films
GET {{baseUrl}}/films

### Delete One film
DELETE {{baseUrl}}/films/5
Authorization: {{admin.response.body.token}}

### Update One film
PUT {{baseUrl}}/films/4
Content-Type: application/json
Authorization: {{jamesToken}}

{
  "title" : "Venom: Let There Be Carnage",
  "duration" : 97,
  "budget" : 110,
  "link" : "https://en.wikipedia.org/wiki/Venom:_Let_There_Be_Carnage"
}
```
<br/>

Plus de d√©tails sur REST Client et ses fonctionnalit√©s : 
https://github.com/Huachao/vscode-restclient
<br/>

# <a id="sectionH"></a>h) Gestion des requ√™tes contenant des objets JSON quelconques
## h.1) Introduction
Dans le cadre du module 1, nous avons vu les moyens principaux de g√©rer des requ√™tes. 

Pour ce module-ci, nous avons √©t√© en contact avec du code permettant :
- de r√©cup√©rer des informations JSON du body d'une requ√™te sans passer par un POJO, 
mais en utilisant un **JsonNode**. 
- de retrouver le contexte d'une requ√™te.
<br/>

Nous allons maintenant expliquer les concepts associ√©s.
<br/>

## h.2) R√©cup√©ration des param√®tres d'une requ√™te d'un objet quelconque
Nous allons souvent souhaiter r√©cup√©rer des donn√©es qui ont √©t√© envoy√©es au format JSON au sein du body d'une requ√™te client.
<br/>

Dans le cas o√π ces donn√©es ne correspondent pas √† un POJO, nous pouvons utiliser 
un param√®tre de type **JsonNode**, et r√©cup√©rer les champs JSON via la m√©thode **get**.
<br/>

Admettons qu'une requ√™te cliente envoie ce JSON : 
```json
{
    "login":"james",
    "password":"password"
}
```
<br/>

La m√©thode **login** de la classe **AuthsResource** permet de r√©cup√©rer cet objet JSON 
et de le parser au sein de l'argument **json** :
```java {5,11-12}
@POST
@Path("login")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public ObjectNode login(JsonNode json) {
    // Get and check credentials
    if (!json.hasNonNull("login") || !json.hasNonNull("password")) {
        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
                .entity("login or password required").type("text/plain").build());
    }
    String login = json.get("login").asText();
    String password = json.get("password").asText();
```
<br/>

Il ne faut pas oublier de pr√©ciser le type MIME de la requ√™te qui sera consomm√©e 
par la m√©thode, ici : **@Consumes(MediaType.APPLICATION_JSON)**.
<br/>

NB : Tout cela est possible car la librairie **Jackson** est bien charg√©e au sein de 
notre application JAX-RS.
<br/>

## h.3) Contexte et @Context
JAX-RS fournit un moyen simple de b√©n√©ficier d'informations associ√©es au contexte du 
d√©ploiement d'une application et du contexte de requ√™tes individuelles. 

Ces informations sont disponibles pour les sous-classes d'**Application**, **Root Resource Classes** et les **providers**. C'est l'annotation **@Context** qui permet, par exemple, d'injecter 
un provider au sein d'une variable (argument d'une m√©thode ou champs d'une classe).
<br/>

Dans le code de la m√©thode **createOne** de **FilmResource**, c'est gr√¢ce √† **@Context** 
que l'on peut r√©cup√©rer le contenu de la requ√™te qui a √©t√© filtr√©e par 
**AuthorizationRequestFilter** :
```java {5-6}
@POST
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@Authorize
public Film createOne(Film film, @Context ContainerRequest request) {
    User authenticatedUser = (User) request.getProperty("user");
    System.out.println("A new film is added by " + authenticatedUser.getLogin() );
```
<br/>

# <a id="sectionI"></a>i) Gestion des r√©ponses et s√©rialisation d'objets JSON quelconques
## i.1) Introduction
Dans le cadre du module 1, nous avons vu les moyens principaux de g√©rer des r√©ponses.
Nous renvoyions toujours des POJOs ou des listes de POJOs. 

Pour ce module-ci, nous avons √©t√© en contact avec du code permettant de s√©rialiser 
des informations et les renvoyer au client sans devoir passer par un POJO, 
mais en cr√©ant ses propres objets JSON.
<br/>

## i.2) S√©rialiser et renvoyer des objets JSON quelconques
Dans le cas o√π des donn√©es √† renvoyer √† un client ne correspondent pas √† un POJO, nous pouvons cr√©er en Java, √† l'aide de librairie **Jackson**, du **JSON** via :
- **JsonNode** si cela peut √™tre la repr√©sentation d'un objet en JSON (**ObjectNode**) 
ou d'un tableau en JSON (**ArrayNode**) ;
- **ObjectNode** pour la repr√©sentation d'un objet en JSON ;
- **ArrayNode**  pour la repr√©sentation d'un tableau en JSON.

<br/>

Admettons que nous souhaitons construire une r√©ponse JSON de ce type : 
```json
{
  "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJhdXRoMCIsInVzZXIiOjF9.JX5Xnp4KDvpkderjcv2W1TmCgwklKpRDIw3vheDSoNg",
  "id": 1,
  "login": "james"
}
```
<br/>

Dans la m√©thode **login** de la classe **AuthsResource**, voici le code permettant 
de renvoyer une repr√©sentation JSON de cet objet via un **ObjectNode** :
```java numbered {6,16,22}
public class AuthsResource {
    //...
    @POST
    @Path("login")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public ObjectNode login(JsonNode json) {
        // Get and check credentials
        if (!json.hasNonNull("login") || !json.hasNonNull("password")) {
            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
                    .entity("login or password required").type("text/plain").build());
        }
        String login = json.get("login").asText();
        String password = json.get("password").asText();
        // Try to login
        ObjectNode publicUser = myUserDataService.login(login, password);
        if (publicUser == null) {
            throw new WebApplicationException(Response.status(Response.Status.UNAUTHORIZED)
                    .entity("Login or password incorrect").type(MediaType.TEXT_PLAIN)
                    .build());
        }
        return publicUser;
    }
    //...
}
```
<br/>

C'est donc la m√©thode **login** de **UserDataService** qui cr√©e la repr√©sentation JSON 
d'un objet contenant un **token**, un **id** et un **login** comme propri√©t√©s. 
Le code permettant de cr√©er une repr√©sentation de cet objet JSON utilise un 
**ObjectMapper** permettant de cr√©er un **ObjectNode** :
```java numbered {3,13-17}
public class UserDataService {
    //...
    private final ObjectMapper jsonMapper = new ObjectMapper();
    //...
    public ObjectNode login(String login, String password) {
        User user = getOne(login);
        if (user == null || !user.checkPassword(password))
            return null;
        String token;
        try {
            token = JWT.create().withIssuer("auth0")
                    .withClaim("user", user.getId()).sign(this.jwtAlgorithm);
            ObjectNode publicUser = jsonMapper.createObjectNode()
                    .put("token", token)
                    .put("id", user.getId())
                    .put("login", user.getLogin());
            return publicUser;

        } catch (Exception e) {
            System.out.println("Unable to create token");
            return null;
        }
    }
    //...
}
```
<br/>

La m√©thode **put** permet d'ajouter des champs √† un objet de type **ObjecNode**.
Nous pouvons ajouter autant de champs que n√©cessaire √† l'objet JSON qui sera 
s√©rialis√© et renvoy√© au client via une Root Resource (**AuthsResource** dans notre exemple).

<br/>

**Code du tutoriel** : si vous souhaitez directement acc√©der au code de la fin du tutoriel de 
cr√©ation d'une API de gestion de films pour ce module 2 : 
https://github.com/e-vinci/baja-demos/tree/main/films-api-module2

<br/>

# <a id="sectionJ"></a>j) Exercice 2.1
Peut-√™tre avez-vous d√©j√† entendu parler de cette mode montante dans le Web 
qu'est la JAMstack ?
<br/>

Nous souhaitons d√©velopper un Headless CMS, c'est-√†-dire un outil permettant 
de cr√©er du contenu, tr√®s souvent utilis√© dans le cadre de sites JAMstack.

Un Headless CMS fournira une interface web pour cr√©er du contenu (ou des donn√©es), 
ainsi qu'une RESTful API mettant √† disposition ce contenu.
<br/>

L'Headless CMS que nous souhaitons d√©velopper doit permettre de cr√©er le contenu 
associ√© √† un blog.

Un blog sera structur√© en pages. Une page aura un id, un titre, un URI, un contenu, 
un auteur ainsi qu'un statut de publication.

Le statut de publication d'une page peut actuellement prendre comme valeur :
- ¬´ hidden ¬ª
- ¬´ published ¬ª

<br/>

Seul un utilisateur authentifi√© pourra lire, cr√©er, modifier ou supprimer des pages.
<br/>

La modification d'une page, tout comme la suppression d'une page ne pourra se faire 
que par son auteur.
<br/>

L'ajout ou la modification d'une page ne sera possible que si le statut de publication 
donn√© correspond √† un des deux statuts actuels (¬´ hidden ou ¬´ published ¬ª). 
Sinon un message d'erreur devra √™tre renvoy√©.
<br/>

La lecture d'une page, ou de toutes les pages, pourra √™tre r√©alis√©e par n'importe
quel utilisateur authentifi√© pour les pages dont le statut vaut ¬´ published ¬ª.
<br/>

Pour les pages dont le statut vaut ¬´ hidden ¬ª, seul leur auteur authentifi√© pourra les lire.
<br/>

Lorsque vous renvoyer les donn√©es associ√©es √† une page, il est acceptable, √† ce stade-ci, 
d'inclure le password dans la r√©ponse faite au client. 
<br/>

Il est aussi acceptable √† ce stade-ci, lorsque vous devez renvoyer une erreur √† un client, de simplement 
renvoyer un code d'erreur (sans mettre de message dans le body de la r√©ponse).
<br/>

Veuillez d√©velopper une application JAX-RS mettant √† disposition les op√©rations 
d√©crites ci-dessus.
<br/>

Dans un premier temps, veuillez formaliser les op√©rations associ√©es √† vos RESTful 
APIs sous forme d'un tableau dans un fichier **README.md**. 

Votre tableau doit reprendre les conventions REST pr√©sent√©es au point 
[c) Rappel de conventions sur les RESTful APIs, authentification & autorisation](/modules/2#sectionC).
<br/>

Comment cr√©er un tableau dans un fichier Markdown  ? 
Deux options :
- Soit vous utiliser des '**|**' pour d√©limiter les cellules et des '**|---|**' pour s√©parer 
les headers du corps du tableau. 
Voici un exemple pour l'API de films :
```text
| URI | M√©thode HTTP | Auths? | Op√©ration |
|---|---|---|---|
| **films** | GET | Non | READ ALL : Lire toutes les ressources de la collection |
| **films?minimumduration=value** | GET | Non | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **films/{id}** | GET | Non | READ ONE : Lire la ressource identifi√©e |
| **films** | POST | JWT | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| **films/{id}** | DELETE | JWT | DELETE ONE : Effacer la ressource identifi√©e |
| **films/{id}** | PUT | JWT | UPDATE ONE : Replacer l'enti√®ret√© de la ressource par les donn√©es de la requ√™te |
```
- Soit c'est simplement un tableau HTML (`<table>`).

<br/>

Lors de l'impl√©mentation de vos RESTful APIs, veuillez tester toutes les 
m√©thodes offertes par votre application JAX-RS √† l'aide d'un client l√©ger (HTTP client d'IntelliJ 
ou Rest Client de VS Code).
<br/>

Les ressources doivent persister au format JSON et vous devez √©chapper les caract√®res dangereux.
<br/>

Veuillez partir d'un archetype Maven comme d√©crit au point 
[Module 1 : b) Cr√©ation d'une premi√®re application sur base d'un Archetype Maven](/modules/1#sectionB).

Veuillez int√©grer √† votre application les fichiers utiles de la d√©mo https://github.com/e-vinci/baja-demos/tree/main/films-api-module2 pr√©sent√©e dans ce module-ci, 
principalement : **pom.xml**, **Authorize**, **AuthorizationRequestFilter**, **Config**, **AuthsResource**, **UserDataService**

<br/>

üç¨ Optionnel : vous souhaitez rapidement d√©couvrir les principes d'une architecture Web associ√©e √† la JAMstack ? https://jamstack.wtf/ 
<br/>

üç¨ Optionnel : si vous souhaitez d√©couvrir le format Markdown, notamment tr√®s souvent utilis√© dans certains sites JAMstack (source des donn√©es pour certains Headless CMS) : 
https://www.markdownguide.org/basic-syntax/
<br/>

**üç¨ Challenges** : 
- **N¬∞1** : Modifiez les autorisations au niveau des op√©rations de lecture (en gras pour la modification) : 
la lecture d'une page, ou de toutes les pages, pourra √™tre r√©alis√©e par n'importe 
quel utilisateur **anonyme ou authentifi√©** pour les pages dont le statut vaut ¬´ published ¬ª.
Pour les pages dont le statut vaut ¬´ hidden ¬ª, seul leur auteur authentifi√© pourra les lire.
- **N¬∞2** : lorsqu'un utilisateur tente d'effacer ou modifier une page dont il n'est pas l'auteur,
renvoyer un code d'erreur appropri√© au client.
- **N¬∞3** : Si vous ne l'avez pas d√©j√† fait, trouvez une fa√ßon de ne pas inclure le password lors de la s√©rialisation de celui-ci dans une page (via l'auteur de la page). Attention, le password doit toujours √™tre s√©rialis√© lors de l'enregistrement d'un utilisateur.


<br/>
