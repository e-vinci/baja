---
title: "Module 1 : d√©couverte de JAX-RS"
description: "D√©couverte de JAX-RS"
---

# Module 1 : d√©couverte de JAX-RS
Ce module vous offre une premi√®re d√©couverte du framework JAX-RS par le biais d'un tutoriel. 

Voici les sujets trait√©s :
- a) [Rappel de conventions sur les RESTful API](/modules/1#sectionA)
- b) [Cr√©ation d'une premi√®re application sur base d'un Archetype Maven](/modules/1#sectionB)
- c) [Premi√®re op√©ration de lecture de ressources JSON](/modules/1#sectionC)
- d) [Gestion des param√®tres de requ√™tes](/modules/1#sectionD)
- e) [Gestion des r√©ponses](/modules/1#sectionE)
- f) [Envoi de requ√™tes √† ses APIs](/modules/1#sectionF)
- g) [S√©rialisation de fichiers JSON](/modules/1#sectionG)
- h) [Gestion des caract√®res dangereux](/modules/1#sectionH)
- i) [Exercice 1.1](/modules/1#sectionI)

<br/>

# <a id="sectionA"></a>a) Rappel de conventions sur les RESTful API
Un RESTful web service, ou RESTful API, met √† disposition des op√©rations sur des ressources. 
Ces op√©rations seront disponibles via des requ√™tes http associ√©es √† des URLs construites 
selon les conventions RESTful.
<br/>

Les RESTful APIs sont **stateless** : le serveur n'enregistre aucune information c√¥t√© serveur 
concernant les sessions des clients. 

Cela permet principalement de rendre l'architecture 
facilement ¬´ scalable ¬ª.Chaque requ√™te vers une RESTful API prot√©g√©e (via JWT) 
devra contenir toutes les donn√©es pour que le client puisse √™tre authentifi√© / autoris√©.
<br/>

Une RESTful API met √† disposition des op√©rations sur des ressources via :
- des URI
- des m√©thodes HTTP
- des repr√©sentations des ressources compr√©hensibles tant par les clients que les serveurs (JSON)

<br/>

Voici un r√©sum√© des conventions associ√©es aux applications REST :
- 1 collection de donn√©es = des ressources (d'un certain type)
- 1 √©l√©ment d'une collection = 1 ressource
- 1 adresse unique pour chaque ressource = 1 URL
- Media type = format de donn√©e repr√©sentant une ressource : JSON, XML, HTML, TXT, JPEG,
PNG‚Ä¶
- Le type d'op√©ration sur une ressource est d√©fini via la m√©thode http de la requ√™te :
  - GET = READ (la ou les ressource(s))
  - POST = CREATE 
  - DELETE = DELETE : )
  - PUT = UPDATE

<br/>

Voici un exemple d'application de ces conventions RESTful dans le cadre d'une RESTful API 
permettant de g√©rer des films :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **films** | GET | READ ALL : Lire toutes les ressources de la collection |
| **films?minimumduration=value** | GET | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **films/{id}** | GET | READ ONE : Lire la ressource identifi√©e |
| **films** | POST | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| **films/{id}** | DELETE | DELETE ONE : Effacer la ressource identifi√©e |
| **films/{id}** | PUT | UPDATE ONE : Replacer l'enti√®ret√© de la ressource par les donn√©es de la requ√™te |

<br/>
Nous allons maintenant d√©velopper une application JAX-RS offrant une API de films.
<br/>
<br/>

# <a id="sectionB"></a>b) Cr√©ation d'une premi√®re application sur base d'un Archetype Maven
Un **archetype Maven** est un boilerplate de projet mis √† disposition sur un repository.
<br/>

Jersey offre diff√©rents archetypes Maven.

Pour plus d'infos: https://eclipse-ee4j.github.io/jersey.github.io/documentation/latest31x/getting-started.html#new-from-archetype 
<br/>

A l'aide d'IntelliJ, **mis √† jour** vers une version r√©cente si vous utilisez votre laptop (2023.3.2 au 12/01/2024), cr√©ez un projet ou un module Maven en utilisant un archetype fournit par Jersey :
- Clic sur **File**, **New**, **Project...**.
- Dans la colonne de gauche, pour **Generators**, clic sur **Maven Archetype**.
- Pour **Name**, vous pouvez indiquer **films-api**.
- Pour le JDK, choisissez une version LTS (21 au 12/01/2024).
- Pour **Catalog**, s√©lectionnez **Maven Central**.
- Pour **Archetype**, s√©lectionnez : **org.glassfish.jersey.archetypes:jersey-quickstart-grizzly2** ; attention √† ne pas prendre l'archetype de **sun** (trop ancienne) mais bien celui de **glassfish**.
- Pour **Version**, la derni√®re sera d√©j√† s√©lectionn√©e : √ßa sera **3.1.5** (au 12/01/2024).
- Clic sur **Advanced Settings**.
- Ajoutez le nom de domaine dans **GroupId**, par exemple : **be.vinci**

<br/>

Explorez ce qui est offert au sein de ce module ou projet :
- Lancez la m√©thode **main** de la classe **Main**.
- Une tout premi√®re m√©thode **getIt** est offerte au sein de la ressource **MyResource**.
- Consommez cette m√©thode **getIt**  √† l'aide d'un client, via un browser, √† l'URL [http://localhost:8080/myresource](http://localhost:8080/myresource).
- Il existe aussi un "acceptance test" qui est offert dans **/src/test/java/be.vinci/MyResourceTest**. N'h√©sitez pas √† stopper l'ex√©cution de votre application et de lancer le test nomm√© **testGetIt**.

<br/>


Pour terminer, veuillez mettre √† jour les versions de vos d√©pendances (directement dans **/pom.xml**).:
- Faites en sorte de configurer aussi votre projet pour b√©n√©ficier de la version LTS de Java, actuellement la version 17.
```markup {6-9}
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.8.1</version>
    <inherited>true</inherited>
    <configuration>
        <source>21</source>
        <target>21</target>
    </configuration>
</plugin>
 ```
- Une fois la configuration mise √† jour, n'oubliez pas de recharcher vos d√©pendances en cliquant sur l'ic√¥ne **Load Maven Changes**.

<br/>

# <a id="sectionC"></a>c) Premi√®re op√©ration de lecture de ressources JSON
## c.1) Introduction
La gestion des ressources est d√©crite dans le manuel utilisateur de Jersey : https://eclipse-ee4j.github.io/jersey.github.io/documentation/latest31x/jaxrs-resources.html

Pour expliquer ces concepts, nous allons d√©velopper la fonction permettant de lire tous les films en continuant le projet initialis√© √† la section pr√©c√©dente.
Nous souhaitons, lorsque nous indiquons [http://localhost:8080/films](http://localhost:8080/films) dans le browser, qu'une liste de films par d√©faut soit renvoy√©e au format JSON vers l'utilisateur.
<br/>

Dans la classe **Main** du projet, on retrouve :
```java
final ResourceConfig rc = new ResourceConfig().packages("be.vinci");
```
Cette ligne de code permet scanner toutes les ressources JAX-RS 
(ainsi que les providers que nous verrons plus tard) pr√©sentes dans le package **be.vinci** et de les d√©ployer au sein d'un container http de Grizzly.
<br/>

Les classes associ√©es √† des ressources (**MyResource** dans ce projet) sont enregistr√©es 
au sein de l'application. Le framework pourra injecter des instances de ces ressources le temps voulu.
<br/>

Pour pouvoir utiliser l'injection de d√©pendances, la librairie de Jersey permettant de le faire a √©t√© install√©e. 
Celle-ci se trouve indiqu√©e de la sorte dans **/pom.xml** :
```markup
 <dependency>
            <groupId>org.glassfish.jersey.inject</groupId>
            <artifactId>jersey-hk2</artifactId>
 </dependency>
 ```

Dans la classe **Main**, la **BASE_URI** pointe normalement d√©j√† vers [http://localhost:8080/](http://localhost:8080/).
```java
public static final String BASE_URI = "http://localhost:8080/";
```
<br/>

## c.2) Root resources
Des ressources d'un m√™me type sont g√©r√©es au sein d'une ¬´ Root Resource Class ¬ª. 
Une Root Resource est un **POJO** annot√©e de **@Path("URI_PATH")**.


Le code pr√©c√©dent indique que la ¬´ Root Resource ¬ª **MyResource** sera mis √† disposition via **/myresource** .
```java {1}
@Path("myresource")
public class MyResource {
```

<br/>
NB : Une Root Resource est l'√©quivalent d'un router sous Express (framework Node.js).
<br/>
<br/>

On souhaite que toutes les op√©rations sur les ressources de type **Film** soient accessibles 
via l'URI "**/films**".
Pour ce faire :
- Renommez la classe **MyResource** en **FilmResource** et sa m√©thode **getIt** en **getAll**.
- Changez le **Path** annotant la classe **FilmResource** vers : 
```java {1}
@Path("films")
public class FilmResource {
```
<br/>

Ajoutez la classe **Film** au sein de votre projet :
```java
package be.vinci;

public class Film {

    private int id;
    private String title;
    private int duration;
    private long budget;
    private String link;

    public Film() {
    }

    public Film(int id, String title, int duration, long budget, String link) {
        this.id = id;
        this.title = title;
        this.duration = duration;
        this.budget = budget;
        this.link = link;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public int getDuration() {
        return duration;
    }

    public void setDuration(int duration) {
        this.duration = duration;
    }

    public long getBudget() {
        return budget;
    }

    public void setBudget(long budget) {
        this.budget = budget;
    }

    public String getLink() {
        return link;
    }

    public void setLink(String link) {
        this.link = link;
    }

    @Override
    public String toString() {
        return "Film [id=" + id + ", title=" + title + ", duration=" + duration + ", budget=" + budget + ", link="
                + link + "]";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Film film = (Film) o;

        return id == film.id;
    }

    @Override
    public int hashCode() {
        return id;
    }
}
```
<br/>

Dans **FilmResource**, utilisez ce code pour cr√©er des films par d√©faut :
```java
private Film[] defaultFilms = {
            new Film(1, "No Time To Die", 163, 301, "https://en.wikipedia.org/wiki/No_Time_to_Die"),
            new Film(2, "Dune", 156, 165, "https://en.wikipedia.org/wiki/Dune_(2021_film)"),
            new Film(3, "Shang-Chi and the Legend of the Ten Rings", 132, 200, "https://en.wikipedia.org/wiki/Shang-Chi_and_the_Legend_of_the_Ten_Rings"),
            new Film(4, "Peter Rabbit 2: The Runaway", 93, 45, "https://en.wikipedia.org/wiki/Peter_Rabbit_2:_The_Runaway")
    };
private List<Film> films = new ArrayList<>(Arrays.asList(defaultFilms)); // to get a changeable list, asList is fixed size
```
<br/>

Veuillez faire en sorte que la m√©thode **getAll** de **FilmResource** renvoie l'ArrayList de films 
et sp√©cifiez que la repr√©sentation des ressources renvoy√©es par votre m√©thode **getAll** est du JSON :
```java
@GET
@Produces(MediaType.APPLICATION_JSON)
    public List<Film> getAll() {
```
<br/>

Une m√©thode annot√©e par **@GET** r√©pondra aux requ√™tes **GET** sur la Root Resource.

Que se passe-t-il si vous tentez d'acc√©der √† une ressource non prise en charge par votre API ? 
N'h√©sitez pas √† essayer, par exemple : [http://localhost:8080/movies](http://localhost:8080/movies). 
<br/>

Pour r√©pondre √† des requ√™tes d'une certaine m√©thode http, on utilisera l'annotation associ√©e : 
par exemple, pour une requ√™te POST, **@POST**‚Ä¶
<br/>

Testez la lecture des films...

Que se passe-t-il ? ¬´ Request failed ¬ª...

L'application n'est pas encore capable de s√©rialiser une ArrayList de films vers du JSON.
<br/>

## <a id="sectionC3"></a>c.3) S√©rialisation via Jackson
Nous allons utiliser un package Jackson pour qu'automatiquement le framework puisse s√©rialiser des objets
JAVA, comme une ArrayList de films, vers du JSON.

Pour ce faire, veuillez ajouter ajoutez une d√©pendance √† Jackson :
- Via IntelliJ, pour ajouter une d√©pendance : 
  - cliquez au sein de votre fichier **/pom.xml** : **Alt + Insert** (macOS: ‚åò Command+N), **Dependency**
  - tapez : **jersey-media-json-jackson**
  - Installez les d√©pendances Maven en cliquant sur le bouton repr√©sentant "**Load Maven Changes**"
- Si vous n'avez pas IntelliJ, vous pouvez simplement rajouter cela dans votre **pom.xml** :
```markup
<dependency>
    <groupId>org.glassfish.jersey.media</groupId>
    <artifactId>jersey-media-json-jackson</artifactId>
</dependency>
```
<br/>

Voila, si vous ex√©cutez votre programme, la lecture des films devrait fonctionner 
sur [http://localhost:8080/films](http://localhost:8080/films)
<br/>

NB : Pour cette version de Jersey, il n'est plus n√©cessaire d'enregistrer l'utilisation de Jackson au sein de l'application.
Dans des versions plus ancienne, il fallait mettre √† jour la classe **Main** :
```java {2}
 final ResourceConfig rc = new ResourceConfig().packages("be.vinci")
                .register(JacksonFeature.class);
```
<br/>

## c.4) Scope de l'injection d'une "Root Resource" au sein du framework
### c.4.1) Scope par d√©faut
Maintenant, nous allons cherchez √† comprendre le scope de la Root Ressource cr√©√©e par le framework.

Pour ce faire, modifiez votre m√©thode **getAll** pour qu'elle essaie d'effacer toujours le dernier 
√©l√©ment du tableau avant de renvoyer tous les √©l√©ments restant du tableau.
```java {3-4}
@GET
    @Produces(MediaType.APPLICATION_JSON)
    public List<Film> getAll() {
        if(films.size()>0)
            films.remove(films.size()-1);
        return films;
    }
```
<br/>

Appelez plusieurs fois votre API dans votre browser, en faisant plusieurs refresh sur 
[http://localhost:8080/films](http://localhost:8080/films)

Que se passe-t-il ?

A chaque fois on repart avec le m√™me tableau par d√©faut de ressources, on a toujours qu'un seul √©l√©ment en moins.
On ne peut donc pas effacer plus d'un √©l√©ment.
<br/>

**Conclusion** : 

Par d√©faut, une nouvelle instance d'une Route Resource sera cr√©√©e pour chaque requ√™te matchant l'URI de la Root Resource. 
C'est comme si la Root Resource avait √©t√© annot√©e par **@RequestScoped**.
Dans une application RESTful, cela n'a pas de sens car elle est "stateless". D√®s lors, comme la r√©ponse √† une requ√™te 
ne d√©pend pas de l'√©tat de la ressource, il est inutile de cr√©er une nouvelle instance de ressource pour chaque requ√™te.
<br/>

Si vous souhaitez plus de d√©tails concernant le cycle de vie de Root Resources : https://eclipse-ee4j.github.io/jersey.github.io/documentation/latest31x/jaxrs-resources.html#d0e2536
<br/>

### c.4.2) Scope : une instance par application JAX-RS

Nous allons modifier le scope de la cr√©ation en ajoutant l'annotation **@Singleton** dans **FilmResource** :
```java {1}
@Singleton
@Path("films")
public class FilmResource {
```
<br/>

Suite √† ce changement, v√©rifiez ce qui se produit au niveau de l'application.

On a bien une seule instance de **FilmResource** qui est inject√©e dans notre application.
D√®s lors, √† chaque refresh de la page, un film est enlev√©, jusqu'√† ce que l'API renvoie comme JSON un tableau vide.
<br/>

Avant de passer au point suivant, nous allons  remettre en ordre la fonction permettant de lire tous les films 
(elle ne doit plus effacer de films).
```java
@GET
@Produces(MediaType.APPLICATION_JSON)
public List<Film> getAll() {
    return films;
}
```
<br/>

# <a id="sectionD"></a>d) Gestion des param√®tres de requ√™tes
## d.1) Param√®tres d'URI via @Path et codes d'erreur
Il est possible d'int√©grer des variables dans des URIs.

Une variable est d√©limit√©e par des ¬´ **{}** ¬ª au sein de l'URI. 

On utilise **@PathParam** pour extraire un param√®tre du chemin d'une URI.
<br/>

Pour l'API de gestion de films, nous allons maintenant d√©velopper l'op√©ration de lecture d'un 
film sur base de son id.

Ajoutez cette nouvelle m√©thode au sein de **FilmResource** : 
```java {1,3-4,7-8}
@GET
@Path("/{id}")
@Produces(MediaType.APPLICATION_JSON)
public Film getOne(@PathParam("id") int id) {
        Film filmFound = films.stream().filter(film -> film.getId() == id).findAny().orElse(null);
        if (filmFound == null)
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity("Ressource not found").type("text/plain").build());
        return filmFound;
    }
```
<br/>

Si vous tapez [http://localhost:8080/films/3](http://localhost:8080/films/3) dans votre browser,
cela correspond √† une requ√™te de type **GET /films/3**. Au sein de la m√©thode **getOne**, le param√®tre 
**id** vaudra 3.
<br/>

Veuillez noter comment un message de statut est renvoy√© au client si aucune resource n'est trouv√©e.

Nous lan√ßons une **WebApplicationException**, en lui passant un code d'erreur (**NOT_FOUND**), et 
nous construisons une r√©ponse en indiquant que le type est du texte (**text/plain**).
D√®s lors, la r√©ponse contiendra le code de statut **404** (√©quivalent de **NOT_FOUND**) et le message 
"Resource not found".
<br/>

Veuillez tester la lecture d'une ressource qui n'existe pas, par exemple via 
[http://localhost:8080/films/5](http://localhost:8080/films/5).
<br/>

## d.2) Param√®tres de requ√™te via @QueryParam
Lors d'une requ√™te par un client, il est possible de passer des param√®tres de requ√™te via l'URL :
**?key1=value1&key2=value2**. 
Ces param√®tres se trouvent apr√®s le **?** dans l'URL, sous forme de paires **cl√©/valeur**.
Quand il y a plusieurs param√®tres, ils sont s√©par√©s par un **&**.
<br/>

Gr√¢ce √† Jersey, on r√©cup√®re ces param√®tres au sein de nos APIs via **@QueryParam**.

Nous allons maintenant offrir la possibilit√© de lire tous les films qui ont une dur√©e minimum 
√† ce qui sera indiqu√© dans un param√®tre de requ√™te, sur base d'une requ√™te de type 
**GET /films?minimum-duration=value**.

Pour ce faire, nous ne devons pas cr√©er de nouvelle m√©thode au sein de **FilmResource** mais 
nous devons mettre √† jour la m√©thode renvoyant tous les films :
```java {3-8}
@GET
@Produces(MediaType.APPLICATION_JSON)
public List<Film> getAll(@DefaultValue("-1") @QueryParam("minimum-duration") int minimumDuration) {
    if (minimumDuration != -1) {
        List<Film> filmsFiltered = films.stream().filter(film -> film.getDuration() >= minimumDuration)
                .toList();
        return filmsFiltered;
    }
    return films;
}
```
<br/>

On r√©cup√®re le param√®tre d'une requ√™te GET nomm√© **minimum-duration** au sein de **minimumDuration**.

Par exemple, pour la requ√™te [http://localhost:8080/films?minimum-duration=160](http://localhost:8080/films?minimum-duration=160), 
**minimumDuration** de **getAll** vaut **160**.

Pour une requ√™te de type **GET /films**, si **minimum-duration** n'est pas indiqu√© dans l'URL, 
le param√®tre **minimumDuration** de **getAll** vaudra **-1** gr√¢ce √† **@DefaultValue("-1")**.
<br/>

## d.3) Donn√©es JSON dans le body de la requ√™te
### d.3.1 ) D√©s√©rialisation de JSON
Nous allons souvent souhaiter r√©cup√©rer des donn√©es qui ont √©t√© envoy√©es au format JSON sein 
du body d'une requ√™te client. Quand c'est le cas, le framework doit pouvoir automatiquement 
d√©s√©rialiser (ou parser) ces donn√©es JSON. En d'autres termes, le framework doit pouvoir injecter 
les donn√©es JSON dans un objet Java.
<br/>

Pour ce faire, notre application JAX-RS a d√©j√† √©t√© correctement configur√©e pour pouvoir 
s√©rialiser / d√©s√©rialiser des donn√©es JSON √† l'aide de Jackson (voir [c.3) S√©rialisation via Jackson](/modules/1#sectionC3))
<br/>

Nous allons d√©velopper l'op√©ration de cr√©ation d'un film au sein de notre application JAX-RS.
Pour appeler cette op√©ration, il faudra faire une requ√™te client de ce type :
```json
POST http://localhost:8080/films 
Content-Type: application/json

{
"title" : "Venom: Let There Be Carnage",
"duration" : 97,
"budget" : 110,
"link" : "https://en.wikipedia.org/wiki/Venom:_Let_There_Be_Carnage"
} 
```
<br/>

Veuillez ajouter la fonction **createOne** au sein de **FilmResource** :
```java {1,3,4}
@POST
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Film createOne(Film film) {
    if (film == null || film.getTitle() == null || film.getTitle().isBlank())
        throw new WebApplicationException(
                Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
    film.setId(films.size() + 1);
    films.add(film);
    return film;
}
```
<br/>

Pour que le JSON de la requ√™te POST puisse √™tre directement pars√© au sein du param√®tre **film**, 
il faut avoir cr√©√© le POJO **Film**, une classe qui contient tous les getters et setters associ√©s 
aux attributs d'une ressource de type **Film**. 

Par d√©faut, Jackson d√©s√©rialise tous les champs **public**. Pour les champs non public, il d√©s√©rialise par d√©faut
tous les champs qui ont un setter.

Attention, pour la d√©s√©rialisation via Jackson, il doit exister un constructeur 
par d√©faut (sans param√®tres) au sein de votre POJO.
C'est pour √ßa qu'il existe ce constructeur dans la classe **Film** :
```java
public Film() {
    }
```
<br/>

La requ√™te pour pouvoir appeler l'op√©ration de cr√©ation d'un film est donn√©e ici : 
[f) Envoi de requ√™tes √† ses APIs](/modules/1#sectionF).
<br/>

Plus d'infos sur la d√©s√©rialisation via Jackson : 

https://www.baeldung.com/jackson-field-serializable-deserializable-or-not
<br/>
<br/>

### d.3.2) Type MIME de la requ√™te et @Consumes 
Afin de permettre la d√©s√©rialisation par le framework, on doit pr√©ciser le type **MIME** de la repr√©sentation de la ressource qui est envoy√©e dans 
le **body** de la requ√™te : 

**@Consumes(MediaType.APPLICATION_JSON)**, **@Consumes("text/plain")**, ‚Ä¶
<br/>

# <a id="sectionE"></a>e) Gestion des r√©ponses
## e.1) R√©ponses & s√©rialisation en JSON de POJOs
Voici en r√©sum√© ce que nous avons d√©j√† vu. 

Pour renvoyer un objet du monde Java sous une repr√©sention JSON √† un client :
- il faut avoir cr√©√© un JavaBean, un POJO comprenant tous les getters associ√©s aux attributs 
de la ressource √† renvoyer : c'est le r√¥le de la classe **Film**.
- il faut indiquer le type de la repr√©sentation de la ressource renvoy√©e via **@Produces** : 
c'est le r√¥le de **@Produces(MediaType.APPLICATION_JSON))** pour renvoyer du JSON.
- Si l'on souhaite renvoyer un tableau d'objets JSON au client, il suffit de renvoyer 
une liste de POJOs via le framework : c'est le r√¥le du type de retour **`List<Film>`** de la m√©thode **getAll**.

<br/>

De plus, le code http de statut renvoy√©, associ√© √† la r√©ponse,
correspond au code 200 quand tout se passe bien (**Status.OK**).
<br/>

## e.2) Type MIME de la r√©ponse et @Produces
On pr√©cisera le type MIME de la ressource qui sera renvoy√© au client via soit : 
**@Produces(MediaType.APPLICATION_JSON)**, **@Produces("text/plain")**, **@Produces("text/html")**‚Ä¶
<br/>

## e.3) Code http √† renvoyer
On ne peut pas toujours renvoyer du JSON suite √† une requ√™te client ainsi qu'un code 
http correspondant au fait que tout est OK (code 200, **Status.OK**).
<br/>

Dans le cadre d'une RESTful API, comme on renvoie g√©n√©ralement des ressources au format JSON, 
la r√©ponse est tr√®s souvent construite par Jersey et Jackson automatiquement. 
D√®s lors, si l'on souhaite envoyer autre chose en retour qu'un POJO qui doit √™tre s√©rialis√©, 
comme un code d'erreur, il va falloir utiliser une m√©thode du framework court-circuitant 
le processus de s√©rialisation.
<br/>

Pour renvoyer des codes d'erreur, nous l'avons d√©j√† apper√ßu pr√©c√©demment, 
nous allons  utiliser le framework pour lancer une **WebApplicationException**. 
Cette exception sera utilis√©e pour construire la r√©ponse √† renvoyer 
au client. Une **WebApplicationException** reprendra tant le ¬´ http status code ¬ª 
qu'√©ventuellement un message d'erreur de type **text/plain** dans le corps de la r√©ponse.

Afin de voir de nouveaux exemple de code d'erreur, nous allons d√©velopper les op√©rations pour 
effacer et mettre √† jour un film. Veuillez ajouter ces deux m√©thodes au sein de **FilmResource** :
```java numbered {6-7,10-11,22-23,26-27}
@DELETE
@Path("/{id}")
@Produces(MediaType.APPLICATION_JSON)
public Film deleteOne(@PathParam("id") int id) {
    if (id == 0) // default value of an integer => has not been initialized
        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory id info")
                .type("text/plain").build());
    Film filmToDelete = films.stream().filter(film -> film.getId() == id).findAny().orElse(null);
    if (filmToDelete == null)
        throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                .entity("Ressource not found").type("text/plain").build());
    films.remove(filmToDelete);
    return filmToDelete;
}

@PUT
@Path("/{id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Film updateOne(Film film, @PathParam("id") int id) {
    if (id == 0 || film == null || film.getTitle() == null || film.getTitle().isBlank())
        throw new WebApplicationException(
                Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
    Film filmToUpdate = films.stream().filter(f -> f.getId() == id).findAny().orElse(null);
    if (filmToUpdate == null)
        throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                .entity("Ressource not found").type("text/plain").build());
    film.setId(id);
    films.remove(film); // thanks to equals(), films is found via its id
    films.add(film);
    return film;
}
```
<br/>

Pour une liste des codes http, vous pouvez consulter : 
https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
<br/>

La classes **jakarta.ws.rs.core.Response.Status** donne acc√®s √† tous les codes de retour : 
**Response.Status.NOT_FOUND**, **Response.Status.BAD_REQUEST**‚Ä¶
<br/>

# <a id="sectionF"></a>f) Envoi des requ√™tes √† son API
## f.1) Test de son API
Dans le cadre de ce cours, vous ne devez pas d√©velopper de frontend (par exemple en HTML / 
JavaScript / CSS) pour tester vos APIs. Cela prendrait trop de temps. 

Nous allons donc utiliser des clients l√©gers permettant de faire des requ√™tes √† nos APIs.

Pour ce cours, vous pouvez choisir d'utiliser IntelliJ ou REST Client pour faire vos requ√™tes.

Comme nous vous encourageons √† utiliser IntelliJ pour d√©velopper votre code Java, il est probablement 
plus ais√© de rester au sein du m√™me environnement de d√©veloppement en utilisant le client HTTP 
d'IntelliJ.
<br/>

## f.2) HTTP Client d'IntelliJ
Dans le cadre de cours, si vous programmez sous IntelliJ, nous vous recommandons d'utiliser son client HTTP pour faire vos requ√™tes vers vos API Rest.
En 2023, HTTP Client a √©volu√© et on peut l'utiliser comme Rest Client, la syntaxe est la m√™me pour ce que l'on souhaite faire dans ce module.
<br/>

Quelques notions pour vos requ√™tes HTTP :
- Il faut cr√©er un fichier **.http** contenant les requ√™tes vers vos RESTful APIs.
<br/>NB : Il est appropri√© de cr√©er un fichier par Root Resource (par type de ressources).
- Chaque requ√™te est introduite par **###** (3 "**#**"" ou plus)
- Pour ex√©cuter une requ√™te, il suffit de cliquer sur **Send Request**
- Lorsqu'on envoie des donn√©es au format JSON, il est important d'avoir un espace, une ligne vide,
avant les accolades (avant le "**&#123;**" )
- On peut d√©finir des "**File variables**" via ce genre de syntaxe : **@baseUrl = http://localhost:8080/films**
<br/>
- Pour utiliser la variable **baseUrl**, il suffit de la mettre entre double accolades. Par exemple, voici 
la requ√™te permettant de lire tous les films :

```json
### Read All films
GET {{baseUrl}}/films
```
<br/>

Nous allons maintenant tester l'API de gestion de films que nous avons cr√©√©e pour tout ce que nous ne pouvons pas tester directement via un browser.
<br/>

Veuillez cr√©er un fichier **films.http** dans un dossier au sein de votre projet (ou de votre module IntelliJ). Ce dossier pourrait s'appeler **requests** par exemple.

Veuillez y ajouter cette requ√™te pour la cr√©ation d'un film et l'ex√©cuter :
```json
@baseUrl = http://localhost:8080
### Create One film
POST {{baseUrl}}/films 
Content-Type: application/json

{
"title" : "Venom: Let There Be Carnage",
"duration" : 97,
"budget" : 110,
"link" : "https://en.wikipedia.org/wiki/Venom:_Let_There_Be_Carnage"
} 
```
<br/>

Veuillez ajouter cette requ√™te de suppression d'un film dans **films.http** et l'ex√©cuter :
```json
DELETE {{baseUrl}}/films/5
```
<br/>

Veuillez ajouter cette requ√™te de suppression d'un film dans **films.http** et l'ex√©cuter :
```json
### Update One film
PUT {{baseUrl}}/films/4
Content-Type: application/json

{
"title" : "Venom: Let There Be Carnage",
"duration" : 97,
"budget" : 110,
"link" : "https://en.wikipedia.org/wiki/Venom:_Let_There_Be_Carnage"
} 
```
<br/>

Si vous souhaitez en savoir plus sur Http Client d'IntelliJ, vous pouvez consulter : https://www.jetbrains.com/help/idea/http-client-in-product-code-editor.html
<br/>

Sachez que malheureusement Http Client est disponible que sur la version "Ultimate" d'IntelliJ ; la version "Community" ne permet pas d'utiliser Http Client üò±.
<br/>

## f.3) REST Client sous VS Code
Dans le cadre de ce cours, nous pouvons aussi utiliser REST Client de Visual Studio Code pour tester nos APIs : 
https://github.com/Huachao/vscode-restclient

<br/>
L'utilisation de Rest Client est la m√™me que pour HTTP Client d'IntelliJ.
<br/>
<br/>

# <a id="sectionG"></a>g) S√©rialisation de fichiers JSON
## g.1) Introduction
L'utilisation de Jackson est document√©e, mais celle-ci semble fort dispers√©e sur le Web.
Nous avons donc r√©sum√© les concepts essentiels ci-dessous. 

Pour ce cours, nous souhaitons que nos ressources soient persistantes, mais sans utiliser de 
syst√®me de gestion de base de donn√©es. Nous allons donc sauvegarder les donn√©es dans un fichier JSON.
<br/>

Pour chaque op√©ration sur un type de ressources : 
- Nous allons charger toutes les ressources se trouvant dans un fichier JSON au sein d'un objet Java, 
une liste d'objets de type **Film** par exemple.
- Si n√©cessaire, dans le cadre d'une op√©ration d'√©criture sur une ou plusieurs ressources, 
nous allons mettre √† jour la liste d'objets Java (ou POJOs).
- Si nous avons r√©alis√© une op√©ration d'√©criture, nous allons faire persister ces changements en 
sauvegardant la liste d'Objets Java dans un fichier JSON. On √©crase donc le fichier JSON √† chaque 
op√©ration d'√©criture.
<br/>
<br/>

Pour rappel, notre application JAX-RS a d√©j√† √©t√© correctement configur√©e pour pouvoir 
s√©rialiser / d√©s√©rialiser des donn√©es JSON √† l'aide de Jackson
 (voir [c.3) S√©rialisation via Jackson](/modules/1#sectionC3)).
<br/>

<br/>

Voici quelques r√©f√©rences malgr√© tout pour la documentation, si vous souhaitez approfondir :
-	Tutoriel reprenant les fonctions principales de Jackson : https://www.baeldung.com/jackson-object-mapper-tutorial 
-	Le point d'entr√©e de Jackson au sein de Jersey : https://eclipse-ee4j.github.io/jersey.github.io/documentation/latest31x/media.html#json.jackson
-	Pour une id√©e de base de la libraire Jackson : https://github.com/FasterXML/jackson-docs ou https://github.com/FasterXML/jackson-databind 

<br/>

## g.2) S√©rialisation d'une liste de POJOs dans un fichier JSON

Pour rendre les ressources persistantes au sein de notre API de gestion de films, veuillez cr√©er 
une nouvelle classe s'appelant **Json**.

Au sein de la classe **Json**, voici le code de la m√©thode **serialize** permettant d'utiliser
le fichier **db.json** pour s√©rialiser (ou enregistrer) plusieurs types de ressources. Veuillez 
bien lire les commentaires pour comprendre le code :
```java
package be.vinci;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

public class Json {
    private static final String DB_FILE_PATH = "db.json";
    private static Path pathToDb = Paths.get(DB_FILE_PATH);
    private static final String COLLECTION_NAME = "films";
    private final static ObjectMapper jsonMapper = new ObjectMapper();

    public static void serialize(List<Film> films) {
        try {
            // if no DB file, write a new collection to a new db file
            if (!Files.exists(pathToDb)) {
                // Create an object and add a JSON array as POJO, e.g. { films:[...]}
                ObjectNode newCollection = jsonMapper.createObjectNode().putPOJO(COLLECTION_NAME, films);
                jsonMapper.writeValue(pathToDb.toFile(), newCollection); // write the JSON Object in the DB file
                return;
            }
            // get all collections : can be read as generic JsonNode, if it can be Object or Array;
            JsonNode allCollections = jsonMapper.readTree(pathToDb.toFile()); // e.g. { users:[...], films:[...]}
            // remove current collection, e.g. remove the array of films
            if (allCollections.has(COLLECTION_NAME)) {
                ((ObjectNode) allCollections).remove(COLLECTION_NAME); //e.g. it leaves { users:[...]}
            }
            // Prepare a JSON array from the list of POJOs for the collection to be updated, e.g. [{"film1",...}, ...]
            ArrayNode updatedCollection = jsonMapper.valueToTree(films);
            // Add the JSON array in allCollections, e.g. : { users:[...], films:[...]}
            ((ObjectNode) allCollections).putArray(COLLECTION_NAME).addAll(updatedCollection);
            // write to the db file allCollections
            jsonMapper.writeValue(pathToDb.toFile(), allCollections);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
<br/>

## g.2) Parsing d'un fichier JSON vers une liste de POJOs
Dans un 1er temps, on va cr√©er un **JSON Node** sur base d'un fichier JSON et la m√©thode **readTree**.
Puis nous pouvons utiliser un **Reader** pour charger une liste de POJOs √† partir du **JSON Node**.

Au sein de la classe **Json**, veuillez rajouter le code de la m√©thode **parse** permettant de 
charger une liste de ressources :
```java
public static List<Film> parse() {
    try {
        // get allCollections
        JsonNode node = jsonMapper.readTree(pathToDb.toFile());
        // accessing value of the specified field of an object node,
        // e.g. the JSON array within "films" field of { users:[...], films:[...]}
        JsonNode collection = node.get(COLLECTION_NAME);
        if (collection == null) // Send an empty list if there is not the requested collection
            return new ArrayList<Film>();
        // convert the JsonNode to a List of POJOs & return it
        return jsonMapper.readerForListOf(Film.class).readValue(collection);
    } catch (FileNotFoundException e) {
        return new ArrayList<Film>(); // send an empty list if there is no db file
    } catch (IOException e) {
        e.printStackTrace();
        return new ArrayList<Film>();
    }
}
```
<br/>

Il faut maintenant mettre √† jour **FilmResource** afin d'utiliser les m√©thodes **serialize** et 
**parse** pour faire persister les ressources :
```java numbered {7,20,35,38,49,55,67,75}
@Singleton
@Path("films")
public class FilmResource {
@GET
@Produces(MediaType.APPLICATION_JSON)
public List<Film> getAll(@DefaultValue("-1") @QueryParam("minimum-duration") int minimumDuration) {
    var films = Json.parse();
    if (minimumDuration != -1) {
        List<Film> filmsFiltered = films.stream().filter(film -> film.getDuration() >= minimumDuration)
                .toList();
        return filmsFiltered;
    }
    return films;
}

@GET
@Path("/{id}")
@Produces(MediaType.APPLICATION_JSON)
public Film getOne(@PathParam("id") int id) {
    var films = Json.parse();
    Film filmFound = films.stream().filter(film -> film.getId() == id).findAny().orElse(null);
    if (filmFound == null)
        throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                .entity("Ressource not found").type("text/plain").build());
    return filmFound;
}

@POST
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Film createOne(Film film) {
    if (film == null || film.getTitle() == null || film.getTitle().isBlank())
        throw new WebApplicationException(
                Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
    var films = Json.parse();
    film.setId(films.size() + 1);
    films.add(film);
    Json.serialize(films);
    return film;
}

@DELETE
@Path("/{id}")
@Produces(MediaType.APPLICATION_JSON)
public Film deleteOne(@PathParam("id") int id) {
    if (id == 0) // default value of an integer => has not been initialized
        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory id info")
                .type("text/plain").build());
    var films = Json.parse();
    Film filmToDelete = films.stream().filter(film -> film.getId() == id).findAny().orElse(null);
    if (filmToDelete == null)
        throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                .entity("Ressource not found").type("text/plain").build());
    films.remove(filmToDelete);
    Json.serialize(films);
    return filmToDelete;
}

@PUT
@Path("/{id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Film updateOne(Film film, @PathParam("id") int id) {
    if (id == 0 || film == null || film.getTitle() == null || film.getTitle().isBlank())
        throw new WebApplicationException(
                Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
    var films = Json.parse();
    Film filmToUpdate = films.stream().filter(f -> f.getId() == id).findAny().orElse(null);
    if (filmToUpdate == null)
        throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                .entity("Ressource not found").type("text/plain").build());
    film.setId(id);
    films.remove(film); // thanks to equals(), films is found via its id
    films.add(film);
    Json.serialize(films);
    return film;
}
}
```
<br/>


# <a id="sectionH"></a>h) Gestion des caract√®res dangereux
Afin de se prot√©ger des attaques XSS (Cross Site Scripting), il faudra √©viter de renvoyer 
du code JavaScript qui pourrait s'ex√©cuter dans le browser des clients.

Pour ce faire, dans le cadre de ce cours, nous vous proposons, lors de l'enregistrement de 
donn√©es qui pourraient √™tre renvoy√©es aux clients, d'√©chapper les caract√®res 
potentiellement dangereux.

Nous utiliserons la librairie **commons-text** d'Apache, mettant notamment √† disposition 
la m√©thode **escapeHtml4**. 
<br/>

Dans le cadre de votre API de gestion de films, veuillez installer la d√©pendance **commons-text** :
- Via IntelliJ : 
  - cliquez au sein de votre fichier **/pom.xml** : **Code**, **Generate...**, **Add dependency...**
  - tapez : **commons-text** et s√©lectionner **org.apache.commons:commons-text**
  - Installez les d√©pendances Maven en cliquant sur le bouton repr√©sentant "**Load Maven Changes**"
- Si vous n'avez pas IntelliJ, ajoutez cela au sein de **/pom.xml**, puis forcer l'installation des d√©pendances :
```markup
<dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-text</artifactId>
            <version>1.11.0</version>
</dependency>
```
<br/>

Mettez √† jour **FilmResource** afin d'√©chapper les caract√®res dangereux lors des op√©rations d'√©criture :
```java {10-11,31-32}
@POST
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Film createOne(Film film) {
    if (film == null || film.getTitle() == null || film.getTitle().isBlank())
        throw new WebApplicationException(
                Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
    var films = Json.parse();
    film.setId(films.size() + 1);
    film.setTitle(StringEscapeUtils.escapeHtml4(film.getTitle()));
    film.setLink(StringEscapeUtils.escapeHtml4(film.getLink()));
    films.add(film);
    Json.serialize(films);
    return film;
}

@PUT
@Path("/{id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Film updateOne(Film film, @PathParam("id") int id) {
    if (id == 0 || film == null || film.getTitle() == null || film.getTitle().isBlank())
        throw new WebApplicationException(
                Response.status(Response.Status.BAD_REQUEST).entity("Lacks of mandatory info").type("text/plain").build());
    var films = Json.parse();
    Film filmToUpdate = films.stream().filter(f -> f.getId() == id).findAny().orElse(null);
    if (filmToUpdate == null)
        throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                .entity("Ressource not found").type("text/plain").build());
    film.setId(id);
    film.setTitle(StringEscapeUtils.escapeHtml4(film.getTitle()));
    film.setLink(StringEscapeUtils.escapeHtml4(film.getLink()));
    films.remove(film); // thanks to equals(), films is found via its id
    films.add(film);
    Json.serialize(films);
    return film;
}
```
<br/>


Le manuel utilisateur de cette librairie est disponible ici : https://commons.apache.org/proper/commons-text/userguide.html

<br/>

**Code du tutoriel** : si vous souhaitez directement acc√©der au code de la fin du tutoriel de 
cr√©ation d'une API de gestion de films pour ce module 1 : 
https://github.com/e-vinci/baja-demos/tree/main/films-api-module1

<br/>

# <a id="sectionI"></a>i) Exercice 1.1
Veuillez cr√©er une application JAX-RS mettant √† disposition des op√©rations CRUD 
(**C**reate, **R**ead, **U**pdate & **D**elete) sur des ressources de type ¬´ texte √† dactylographier ¬ª.

Les ressources doivent persister au format JSON et vous devez √©chapper les caract√®res dangereux.
<br/>

Veuillez partir d'un archetype Maven comme d√©crit au point 
[b) Creation d'une premi√®re application sur base d'un Archetype Maven](/modules/1#sectionB).
<br/>

Un texte √† dactylographier contient comme attributs : 
- **id**, un entier ;
- **content**, un contenu textuel ;
- **level**, le niveau associ√© au texte. Les seules valeurs autoris√©es sont : 
¬´ **easy** ¬ª, ¬´ **medium** ¬ª et ¬´ **hard** ¬ª.

<br/>

Voici le tableau formalisant toutes les op√©rations associ√©es √† votre RESTful API que vous 
devez impl√©menter :
<br/>

| URI |	M√©thode |	M√©thode |
|-----|---------|-----------|
| **texts**	| GET |	READ ALL : Lire toutes les ressources de la collection |
| **texts?level=value**	| GET |	READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **texts/{id}** | GET | READ ONE : Lire la ressource identifi√©e |
| **texts**	| POST	| CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| **texts/{id}** |	DELETE	| DELETE ONE : Effacer la ressource identifi√©e |
| **texts/{id}** |	PUT	| UPDATE ONE : Remplacer l'enti√®ret√© de la ressource par les donn√©es de la requ√™te |

<br/>

Si lors d'une demande d'ajout ou de modification d'un texte √† dactylographier la valeur 
de **level** ne correspond pas √† une valeur autoris√©e, veuillez renvoyer un code d'erreur 
ainsi que le message d'erreur suivant : ¬´ Lacks of mandatory info or unauthorized text level ¬ª.
<br/>

Veuillez tester toutes les m√©thodes offertes par votre application JAX-RS √† l'aide du client HTTP 
d'IntelliJ ou de REST Client (VS Code).
